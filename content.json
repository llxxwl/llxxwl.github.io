{"pages":[{"title":"分类","text":"","path":"categories/index.html"},{"title":"标签","text":"","path":"tags/index.html"},{"title":"about me","text":"姓名：lpower邮箱：1573903194@qq.com","path":"about-me/index.html"}],"posts":[{"title":"七牛云批量压缩打包文件","date":"2021-11-24T07:06:58.000Z","path":"2021/11/24/七牛云批量压缩打包文件/","text":"记录总共有多少文件需要打包1234// 缓存作品数$redis = \\Yii::$app-&gt;redis;$redis-&gt;set('count' . $id, $count);$redis-&gt;expire('count' . $id, 86400); 视频文件从vod下载到七牛云 首先需要视频在vod的标识vid，根据vid来获取播放地址。获取播放地址的api在阿里云的文档里写的很清楚，详情见api文档，sdk示例见sdk文档 区分高清和标清 123456789101112// 根据清晰度下载到七牛云if (!empty($info-&gt;PlayInfoList-&gt;PlayInfo)) { $playInfo = $info-&gt;PlayInfoList-&gt;PlayInfo; foreach ($playInfo as $item) { if ('FD' == $item-&gt;Definition) { echo \"标清\"; } if ('LD' == $item-&gt;Definition) { echo \"高清\"; } }} 记录下载失败数据 1234567$redis = \\Yii::$app-&gt;redis;// 需要打包文件数减1$redis-&gt;decr('count' . $this-&gt;id);// 记录失败的详细数据。 这里最好用数据的标识，以便之后的查询$redis-&gt;sadd('failDownLoad', '标识');// 设置过期时间$redis-&gt;expire('failDownLoad', 86400); 视频文件（url）下载到七牛云，采用的是异步第三方文件抓取方式 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public function downloadSourceToQiniu($id, $creationId, $fileUrl, $bucket = '', $moduleId = 1) { // 地址转换 $key = ''; if (strpos($fileUrl, '.com/')) { list($domain, $key) = explode('.com/', $fileUrl); } if (strpos($fileUrl, '.cn/')) { list($domain, $key) = explode('.cn/', $fileUrl); } $fileKey = $key; // 作品信息 $redis = \\Yii::$app-&gt;redis; $key = 'download' . $id; if (!empty($creation)) { $title = $creation['title'] ?? ''; $name = !empty($creation['author_name']) ? $creation['author_name'] : (!empty($creation['user_name']) ? $creation['user_name'] : $creation['user_nick']); $redis-&gt;sadd($key, $fileKey . '*' . $creation['number'] . '*' . $title . '*' . $name . '*' . $moduleId); $redis-&gt;expire($key, 86400); } $scheme = \"http://\"; if ($this-&gt;config-&gt;useHTTPS === true) { $scheme = \"https://\"; } $apiUrl = $scheme . $this-&gt;apiHost. '/sisyphus/fetch'; // 回调函数 $callbackurl = $this-&gt;callback ?? ''; /*如果不指定储存，则用默认储存*/ if (empty($bucket)) { $bucket = $this-&gt;bucket; } $count = $redis-&gt;get('count' . $id); // 这里所有的参数都可以在回调函数中拿到 $body = json_encode(['url' =&gt; $fileUrl, 'bucket' =&gt; $bucket, 'key' =&gt; $fileKey, 'callbackurl' =&gt; $callbackurl, 'callbackbody' =&gt; 'key=$(key)&amp;hash=$(etag)&amp;size=$(fsize)&amp;h=$(imageInfo.height)&amp;moduleId='. $moduleId . '&amp;id='.$id . '&amp;creationId=' . $creationId . '&amp;count=' . $count]); $headers = $this-&gt;auth-&gt;authorizationV2($apiUrl, 'POST', $body, 'application/json'); $headers[\"Content-Type\"] = 'application/json'; $headers[\"Host\"] = $this-&gt;apiHost; $response = Client::post($apiUrl, $body, $headers); if (!$response-&gt;ok()) { return array(null, new Error($apiUrl, $response)); } $r = $response-&gt;json(); // 新建一个hash表做计数用，用来判断下载到七牛云的资源是否已经全部完成 $redis-&gt;hmset($id, $fileKey . $creationId, $r['id']); $redis-&gt;expire($id, 86400); return $r;} 回调函数1234567891011121314151617181920212223public function actionOssDownloadcallback() { $qiniuInfo = \\Yii::$app-&gt;params['qiniu']; $post = \\Yii::$app-&gt;request-&gt;post(); if (!empty($post['key']) &amp;&amp; !empty($post['id'])) { $key = $post['key']; $id = $post['id']; $creationId = $post['creationId']; $count = $post['count']; $redis = \\Yii::$app-&gt;redis; $len = $redis-&gt;hlen($id); // 如果哈希表为空，代表文件全部下载完成，到压缩程序 if ((int)$count == $len) { $redis-&gt;del($id, 'count' . $id); // 数据表里改变下载状态为正在下载中 $qiniu = new Qiniu($qiniuInfo); // 压缩打包回调函数 $callback = $qiniuInfo['callbackUrl']. 'v1/oss/fopdownload'; // 压缩打包函数 $qiniu-&gt;fopDownload($id, $creationId, $callback); } } return $qiniuInfo['httpUrl'];} 将所有下载好的文件打包，打包文档（大量文件压缩，mode=4） 拼接索引文件：用之前存在redis的数据查询索引文件所需要的信息，拼接成字符串 以二进制流的形式上传到七牛云上，SDK文档 123456789101112public function uploadIndexFile($index, $filename, $bucket) { // 上传索引文件到七牛云 $qiniuInfo = \\Yii::$app-&gt;params['qiniu']; $auth = new Auth($qiniuInfo['accessKey'], $qiniuInfo['secretKey']); // 生成上传Token $token = $auth-&gt;uploadToken($bucket, $filename); // 构建UploadManager对象 $uploadMgr = new UploadManager(); list($ret, $err) = $uploadMgr-&gt;put($token, $filename, $index); return ['result' =&gt; $ret, 'err' =&gt; $err]; } 压缩文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public function fopDownload($id, $creationId, $notifyUrl = '', $bucket = '', $pipLine = '', $force = false) { // $fileInfo = $this-&gt;getFileWithoutExt($fileKey); /*如果不指定储存，则用默认储存*/ if (empty($bucket)) { $bucket = $this-&gt;bucket; } $redis = \\Yii::$app-&gt;redis; // 下载失败文件记录 $fails = $redis-&gt;smembers('failDownLoad' . $id); if (!empty($fails)) { $records = '未下载成功文件有：'; // 这里拼接未下载成功提示 ... $failName = \"下载失败数据详情.txt\"; $failFile = $this-&gt;uploadIndexFile($records, $failName, $bucket); } // 构建索引文件 $members = $redis-&gt;smembers('download' . $id); if (!empty($members)) { // 这里构建索引文件 ... if (isset($failFile['result']['key'])) { // 这里url要base64转码，详情见压缩文档 $index .= 'url/' . base64_urlSafeEncode($this-&gt;httpUrl . $failFile['result']['key']); // 删除缓存 $redis-&gt;del('failDownLoad' . $id); } if (!empty($actInfo)) { // 索引文件命名 $filename = $actInfo['user_id'] . '_' . $actInfo['act_id'] .'_' . $actInfo['id'] . '.txt'; $file = $this-&gt;uploadIndexFile($index, $filename, $bucket); if (!is_null($file['result'])) { $fileKey = $file['result']['key']; /*如果不指定队列，则用默认队列*/ if (empty($pipLine)) { $pipLine = $this-&gt;pipLine; } /*实例化*/ $pfop = new PersistentFop($this-&gt;auth, $this-&gt;config); $fops = \"mkzip/4/|saveas/\" . base64_urlSafeEncode($bucket . ':' . $id . '/' . $actInfo['title'] . '-附件集合' . '.zip'); list($ret, $err) = $pfop-&gt;execute($bucket, $fileKey, $fops, $pipLine, $notifyUrl, $force); } } } return ['err' =&gt; $err, 'result' =&gt; $ret];} 回调函数 1234567891011121314151617public function actionFopdownload() { $qiniuInfo = \\Yii::$app-&gt;params['qiniu']; $post = \\Yii::$app-&gt;request-&gt;post(); if (!empty($post['id'])) { $id = $post['id']; $auth = new Auth($qiniuInfo['accessKey'], $qiniuInfo['secretKey']); $config = new Config(); // 返回持久化id $pfop = new PersistentFop($auth, $config); list($ret, $err) = $pfop-&gt;status($id); if (!is_null($ret)) { // 更改数据表状态为下载完成 ... } } return $qiniuInfo['httpUrl'];} 持久化 上面涉及到七牛云的过程几乎都会用到持久化数据处理。持久化用于满足数据处理时间较长、计算量较大的场景，并且可以随时获取处理进度信息。在资源处理时，自动触发 文档地址：https://developer.qiniu.com/dora/1291/persistent-data-processing-pfop","tags":[{"name":"代码","slug":"代码","permalink":"http://lpower.com/tags/代码/"}]},{"title":"supervisor","date":"2021-08-03T11:38:06.000Z","path":"2021/08/03/supervisor/","text":"简介Supervisor是一个客户/服务器系统，可以在类unix系统中管理控制大量进程。使用python开发。 服务器端：supervisord，主要负责在启动自身时启动管理的子进程，响应客户端的命令，重启崩溃或退出的子进程，记录子进程stdout和stderr输出，生成和处理子进程生命周期中的事件。可以在一个配置文件中配置相关参数，包括supervisor的自身的状态，其管理的各个子进程的相关属性。配置文件一般位于/etc/supervisord.conf 客户端：supervisorctl，它提供了一个类shell的接口（即命令行）来使用supervisord服务端提供的功能。通过客户端，用户可以连接到supervisord服务器进程，获得服务器进程控制的子进程的状态，启动和停止子进程，获得正在运行的进程列表，客户端通过Unix域套接字或者TCP套接字与服务端进行通信，服务端具有身份凭证认证机制，可以有效提升安全性。当客户端和服务器位于同一台机器上时，客户端和服务器共用同一个配置文件，通过标签来区分两者的配置 安装与配置 Ubuntu下安装：sudo apt-get install supervisor。 配置：安装成功后，会在/etc/supervisor目录下，生成supervisord.conf配置文件。也可以使用echo_supervisord_conf &gt; supervisord.conf命令生成默认配置文件 123456789101112131415161718192021222324252627282930配置文件实例：; 带;的是注释行; supervisor config file[unix_http_server]file=/var/run/supervisor.sock ; (the path to the socket file)chmod=0700 ; sockef file mode (default 0700)[supervisord]logfile=/var/log/supervisor/supervisord.log ; (main log file;default $CWD/supervisord.log)pidfile=/var/run/supervisord.pid ; (supervisord pidfile;default supervisord.pid)childlogdir=/var/log/supervisor ; ('AUTO' child log dir, default $TEMP); the below section must remain in the config file for RPC; (supervisorctl/web interface) to work, additional interfaces may be; added by defining them in separate rpcinterface: sections[rpcinterface:supervisor]supervisor.rpcinterface_factory = supervisor.rpcinterface:make_main_rpcinterface[supervisorctl]serverurl=unix:///var/run/supervisor.sock ; use a unix:// URL for a unix socket; The [include] section can just contain the \"files\" setting. This; setting can list multiple files (separated by whitespace or; newlines). It can also contain wildcards. The filenames are; interpreted as relative to this file. Included files *cannot*; include files themselves.[include]files = /etc/supervisor/conf.d/*.conf 进程配置会读取/etc/supervisor/conf.d目录下的配置文件。xx.conf如下 12345678910[program:xx] ; 程序名称，在 supervisorctl 中通过这个值来对程序进行一系列的操作process_name=%(program_name)s_%(process_num)02dcommand=/opt/remi/php73/root/usr/bin/php program/artisan queue:work --sleep=3 --tries=3 // 执行的命令autostart=true ; 在 supervisord 启动的时候也自动启动autorestart=true ; 程序异常退出后自动重启user=root ; 用哪个用户启动numprocs=3redirect_stderr=true ; 把 stderr 重定向到 stdout，默认 falsestdout_logfile=/data/logs/xx.log ; log文件stopwaitsecs=3600 启动：supervisord 常用命令： 123456supervisorctl stop program_name 停止某个进程supervisorctl start program_name 启动某个进程supervisorctl restart program_name 重启某个进程supervisorctl stop all 停止全部进程supervisorctl reload 载入最新的配置文件，停止原有进程并按新的配置启动、管理所有进程supervisorctl update 根据最新的配置文件，启动新配置或有改动的进程，配置没有改动的进程不会受影响而重启","tags":[{"name":"linux","slug":"linux","permalink":"http://lpower.com/tags/linux/"}]},{"title":"PHP面试","date":"2020-03-17T01:04:34.000Z","path":"2020/03/17/PHP面试/","text":"自我介绍 自我介绍是一个很重要的环节，一个好的自我介绍，会让面试官眼前一亮，有继续了解你的欲望 PHP基础1. 什么是面向对象：面向对象编程是软件开发方法，可以提高软件的重用性、灵活性和扩展性。包括类（定义了一件事物的抽象特点）与对象（类的实例），优势在于类的复用 2. 面向对象的三大特性 2.1 封装：只有特定类的对象可以访问这一特定类的成员，信息隐藏，将类的使用和实现分开，避免耦合 2.2 继承：一个类会有子类，子类会继承父类的属性和行为，增加了代码的可重用性 2.3 多态：一个类实例的相同方法在不同情形有不同的表现形式，增强了软件的灵活性，确切的含义是：同一类的对象收到相同消息时，会得到不同的结果。而这个消息是不可预测的 3. PHP基础函数 3.1 操作数组的函数 array_pop 删除数组中最后一个函数 array_merge 合并数组 array_push 向数组中添加元素 sort 数组排序 count 数组计数 array_search 查找数组中元素 array_unique 去重 array_shift 删除数组中首个元素 array_unshift 插入首个元素 3.2 操作字符串的函数 1234567trim 去除特殊字符explode 分割字符串implode 合成字符串strrev 字符串反转strpos 字符串检索strcmp 字符串比较strlen 字符串长度 [完整的字符串和数组函数](http://note.youdao.com/noteshare?id=84d22d5db2c27508804867c9228f1259) 4. 面向对象设计五大原则 4.1 开放封闭原则(osp)一个模块在扩展性方面是开放的，在更改性方面是封闭的。核心思想就是对抽象编程。能够提高系统的可扩展性和可维护性 4.2 单一职责原则(srp)可以减少类之间的耦合，提高代码复用性。适配工厂模式、命令模式 4.3 里氏替换原则(lsp)子类型必须能够替换掉他们的父类型、并出现在父类能够出现的任何地方 4.4 依赖倒置原则(dip)上层模块不应该依赖于下层模块，他们共同依赖于一个抽象；抽象不能依赖于具体，具体应该依赖于抽象 4.5 接口隔离原则(isp) 5. 魔术方法(以两个下划线__开头，具有特殊作用的方法) 5.1 __construct 构造函数，实例化对象时被调用 5.2 __set和__get函数：是两个比较重要的魔术方法，这两个方法被归类到重载，动态的创建类属性和方法。作用是当给对象属性赋值或者取值时，即使这个属性不存在，也不会报错，一定程度上增强了程序的健壮性 5.3 __call和__callStatic方法：和上面的两个魔术方法一样，也是PHP的重载。当调用一个不可访问的方法(如未定义或不可见)时，__call方法会被调用。作用是防止调用不存在的方法而出错。 5.4 toString和debugInfo方法：格式化输出这个对象所包含的数据。tostring=》print_r debuginfo=》var_dump 6. 命名空间：命名空间是一种封装事务的方法。在PHP中，命名空间用来解决在创建可重用的代码时碰到的两类问题： 1) 用户编写的代码与PHP内部的类/函数/常量或第三方类之间的名字冲突 2) 为很长的标识符名称创建一个别名，提高代码的可读性 7. 自动加载：PHP5.1.2之后，提供了自动加载类的方法----spl_autoload_register。有了这个方法，我们就不用每个文件都去加载了 8. 接口：接口常用来作为类与类之间的一个“协议”，接口是抽象类的变体，接口中所有方法都是抽象的，接口为抽象而生。在程序里，接口的所有方法都必须被全部实现，否则会报fetal错误 9. PHP中的错误级别： deprecated是最低级别的错误，表示不推荐，不建议 notice一般是语法存在不当的地方，如未定义的变量等，不影响PHP正常流程 warning是级别比较高的错误，一般在语法中有很不恰当的地方才会触发，比如函数参数不匹配，这类错误会得不到预期结果 fetal error是致命错误，会导致PHP流程终结 最高级别的错误是语法解析错误prase error，语法错误，导致PHP无法通过语法检查 10. echo，print，print_r的区别 print和echo是语言结构，echo可以输出多个值，无返回值；print只能输出一个值，有返回值，都能输出整形和字符串，没法打印bool型。print_r除了输出整形和字符串，还可以输出数组和对象 11. 按值传递和按引用传递的区别 按值传递：在函数内部的修改在函数外部都会被忽略 按引用传递：在函数内部的修改在函数外部也会反映 12. PHP的垃圾回收机制 PHP的变量存储在变量容器zval中，zval中除了存储变量类型和值外，还有is_ref和refcount字段。Refcount表示指向变量的元素个数，is_ref表示变量是否有别名。如果refcount为0时，就回收该变量容器。如果一个zval的refcount-1之后大于0，他就会进入垃圾缓冲区。当缓冲区达到最大值后，回收算法会循环遍历zval，判断其是否为垃圾，并进行释放处理 网络基础1. osi七层模型 应用层：FTP、DNS、HTTP、SMTP 表示层 会话层 传输层：TCP、UDP 网络层：IP、ARP 数据链路层 物理层 2. HTTP协议：HTTP协议是一个应用层协议，由请求和响应构成，是一个标准的客户端和服务器模型。默认的HTTP端口是80，https的端口是443 3. 常见状态码 200 OK：客户端请求成功 301 Moved Permanently：表客户请求的文档被移动到其他地方，新的url在location头中给出 400 客户端请求有语法错误 401 请求未经授权 403 服务器收到请求，但拒绝提供服务 404 请求资源不存在，例如输入了错误的URL 451 由于当前地区法律原因而不可用 500 服务器发生不可预期的错误 503 服务器当前不能处理客户端的请求，一段时间后恢复正常 4. Cookie Cookie在远程浏览器端存储数据并以此跟踪和识别用户的机制。从实现上说，Cookie是存储在客户端的一小段数据，浏览器通过HTTP协议和服务器端进行cookie交互。cookie通常用于存储一些不是很敏感的信息，或者是进行登陆控制，也可用来记住用户名、记住免密码登录，防止刷票等 5. Session Session即会话，指一种持续性的、双向的连接。针对Web网站来说，session指用户在浏览某个网站时，从进入网站到浏览器关闭这段时间内的会话。PHP的Session默认通过文件的方式实现","tags":[]},{"title":"设计模式","date":"2019-11-17T09:52:51.000Z","path":"2019/11/17/设计模式/","text":"设计模式 五大原则（SOLID） 单一职责原则（SRP）：一个类只应承担一种责任 开放-封闭原则（OCP）：实体可扩展，不可修改。面对需求，对程序的改动是通过增加新代码进行的，而不是更改现有的代码 里氏替换原则（LSP）：一个对象在其出现的任何地方，都可以用子类实例做替换，并且不会导致程序的错误 接口分离原则（ISP）：一个类实现的接口中，包含了它不需要的方法。将接口拆分成更小的和更具体的接口，有助于解耦。从而更容易重构、解耦 依赖倒置原则（DIP）：高层次的模块不应该依赖低层次的模块、他们都应该依赖于抽象。抽象不应该依赖于具体实现，具体实现应依赖抽象。针对接口编程，不要对实现编程 迪米特法则（Lod）：如果两个类不彼此直接通信，那么这两个类就不应当发生直接的相互作用。如果其中一个类需要调用另一个类的某一个方法的话，可以通过这个第三者转发这个调用。在类的结构设计上，每一个类都应当尽量降低成员的访问权限简单工厂模式 又称静态工厂方法。专门定义一个类来负责其他类的实例，被创建的实例通常都具有共同的父类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687&lt;?php//简单工厂模式class Operation{ protected $a = 0; protected $b = 0; public function setA($a) { $this-&gt;a = $a; } public function setB($b) { $this-&gt;b = $b; } public function getResult() { $res = 0; return $res; }}class OperationAdd extends Operation{ public function getResult() { return $this-&gt;a + $this-&gt;b; }}class OperationMul extends Operation{ public function getResult() { return $this-&gt;a * $this-&gt;b; }}class OperationSub extends Operation{ public function getResult() { return $this-&gt;a - $this-&gt;b; }}class OperationDiv extends Operation{ public function getResult() { if ($this-&gt;b == 0) { return \"被除数不能为0\"; } return $this-&gt;a / $this-&gt;b; }}class OperationFactory{ public static function createOpreation($operation) { switch ($operation) { case '+': $oper = new OperationAdd(); break; case '-': $oper = new OperationSub(); break; case '*': $oper = new OperationMul(); break; case '/': $oper = new OperationDiv(); break; default: break; } return $oper; }}$operation = OperationFactory::createOpreation('+');$operation-&gt;setA(1);$operation-&gt;setB(2);echo $operation-&gt;getResult() . PHP_EOL; 单例模式 保证一个类只有一个实例，并提供一个访问它的全局访问点。让类自身负责保存它的唯一实例。这个类可以保证没有其它实例可以被创建，并且他可以提供一个访问该实例的方法。 可以严格地控制客户怎样访问以及何时访问他。简单地说就是对唯一实例的受控访问 1234567891011121314151617181920212223242526&lt;?php//单例模式class Singleton{ private static $instance; private function __construct() { } public static function getInstance() { if (static::$instance == null) { static::$instance = new Singleton(); } return static::$instance; }}$s1 = Singleton::getInstance();$s2 = Singleton::getInstance();if ($s1 == $s2) { echo 'same class';} 工厂方法模式 定义一个用于创建对象的接口，让子类决定实例化哪个类。工厂方法使一个类的实例化延迟到其子类 实现时，客户端需要决定实例化哪一个工厂来实现运算类，选择判断的问题还是存在的，也就是说，工厂方法把简单工厂的内部逻辑判断移动到了客户端代码执行，如果要添加功能，本来应该修改工厂类，现在是修改客户端 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102&lt;?php//工厂方法模式class Operation{ protected $a = 0; protected $b = 0; public function setA($a) { $this-&gt;a = $a; } public function setB($b) { $this-&gt;b = $b; } public function getResult() { $res = 0; return $res; }}class OperationAdd extends Operation{ public function getResult() { return $this-&gt;a + $this-&gt;b; }}class OperationMul extends Operation{ public function getResult() { return $this-&gt;a * $this-&gt;b; }}class OperationSub extends Operation{ public function getResult() { return $this-&gt;a - $this-&gt;b; }}class OperationDiv extends Operation{ public function getResult() { if ($this-&gt;b == 0) { return \"被除数不能为0\"; } return $this-&gt;a / $this-&gt;b; }}interface Ifactory{ public function CreateOperation();}class AddFactory implements Ifactory{ public function CreateOperation() { return new OperationAdd(); }}class SubFactory implements IFactory{ public function CreateOperation() { return new OperationSub(); }}class MulFactory implements IFactory{ public function CreateOperation() { return new OperationMul(); }}class DivFactory implements IFactory{ public function CreateOperation() { return new OperationDiv(); }}//客户端代码$operationFactory = new AddFactory();$operation = $operationFactory-&gt;CreateOperation();$operation-&gt;setA(10);$operation-&gt;setB(10);echo $operation-&gt;getResult().\"\\n\"; 抽象工厂模式 提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类 所有在用简单工厂的地方，都可以考虑用反射技术来去除switch或if，解除分支判断代码的耦合 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141&lt;?php//抽象工厂模式class User{ private $id = null; public function setId($id) { $this-&gt;id = $id; } public function getId($id) { return $this-&gt;id; } private $name = null; public function setName($name) { $this-&gt;name = $name; } public function getName($name) { return $this-&gt;name; }}class Department{ private $id = null; public function setId($id) { $this-&gt;id = $id; } public function getId($id) { return $this-&gt;id; } private $name = null; public function setName($name) { $this-&gt;name = $name; } public function getName($name) { return $this-&gt;name; }}interface IUser{ public function insert(User $user); public function getUser($id);}class SqlserverUser implements IUser{ public function insert(User $user) { echo \"往SQL Server中的User表添加一条记录\\n\"; } public function getUser($id) { echo \"根据id得到SQL Server中User表一条记录\\n\"; }}class AccessUser implements IUser{ public function insert(User $user) { echo \"往Access Server中的User表添加一条记录\\n\"; } public function getUser($id) { echo \"根据id得到Access Server中User表一条记录\\n\"; }}//简单工厂替换抽象工厂class DataBase{ const DB = 'Access'; // private $db = 'Access'; public static function CreateUser() { $class = static::DB . 'User'; return new $class(); } public static function CreateDepartment() { $class = static::DB . 'Department'; return new $class(); }}interface IDepartment{ public function insert(Department $user); public function getDepartment($id);}class SqlserverDepartment implements IDepartment{ public function insert(Department $department) { echo \"往SQL Server中的Department表添加一条记录\\n\"; } public function getDepartment($id) { echo \"根据id得到SQL Server中Department表一条记录\\n\"; }}class AccessDepartment implements IDepartment{ public function insert(Department $department) { echo \"往Access Server中的Department表添加一条记录\\n\"; } public function getDepartment($id) { echo \"根据id得到Access Server中Department表一条记录\\n\"; }}//改为简单工厂后的客户端代码$user = new User();$iu = DataBase::CreateUser();$iu-&gt;insert($user);$iu-&gt;getUser(1);$department = new Department();$id = DataBase::CreateDepartment();$id-&gt;insert($department);$id-&gt;getDepartment(1); 观察者模式 定义了一种多对多的依赖关系，让多个观察者对象同时监听某一个主体对象。当一个对象的状态发生改变时，所有依赖他的对象都得到通知并自动刷新 符合接口隔离原则，实现了对象之间的松耦合 抽象主题（subject）：他把所有的观察者对象的引用保存到一个聚集里，每个主题都可以有任何数量的观察者。抽象主题提供一个接口，可以增加和删除观察者对象 具体主题（concretesubject）：将有关状态存入具体观察者对象；在具体主题内部状态改变时，给所有登记过的观察者发通知 抽象观察者（observer）：为所有的具体观察者定义一个接口，在得到主题通知时更新自己 具体观察者（concreteobserver）：实现抽象观察者角色所需要的更新接口，以便使本身的状态与主题状态协调 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778&lt;?php//观察者模式//抽象主题：提供一个接口，增加和删除对象abstract class Subject{ private $observers = []; public function attach(Observer $observer) { array_push($this-&gt;observers, $observer); } public function detatch($observer) { foreach ($this-&gt;observers as $key =&gt; $value) { if ($observer === $value) { unset($this-&gt;observers[$key]); } } } public function notify() { foreach ($this-&gt;observers as $observer) { $observer-&gt;update(); } }}//抽象观察者，为所有的具体观察者定义一个接口，在得到主题是更新自己abstract class observer{ abstract function update();}//具体主题，发生改变时，给所有登记过的观察者发出通知class ConcreteSubject extends Subject{ private $subjectState; public function setState($state) { $this-&gt;subjectState = $state; } public function getState() { return $this-&gt;subjectState; }}//具体观察者：实现抽象观察者角色所要求的的更新接口，以便使本身的状态与主体状态协调class ConcreteObserver extends Observer{ private $name; private $subject; function __construct(ConcreteSubject $subject, $name) { $this-&gt;subject = $subject; $this-&gt;name = $name; } public function update() { echo \"观察者 \" . $this-&gt;name . \"的新状态是:\" . $this-&gt;subject-&gt;getState() . \"\\n\"; }}$s = new ConcreteSubject();$s-&gt;attach(new ConcreteObserver($s, \"x\"));$s-&gt;attach(new ConcreteObserver($s, \"y\"));$z = new ConcreteObserver($s, \"z\");$s-&gt;attach($z);$s-&gt;detatch($z);$s-&gt;setState('ABC');$s-&gt;notify(); 模板方法模式 定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变算法的节结构即可重定义该算法的某些特定步骤 既然用了继承，并且肯定这个继承有意义，就应该要成为子类的模板，所有重复的代码都应该要上升到父类去，而不是让每个子类去重复。当我们要完成某一细节层次一致的一个过程或一系列步骤，但其中个别的步骤在更详细的层次上的实现可能不同时，我们通常考虑用模板方法模式 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091&lt;?php // 对甲乙两名同学所抄试卷，尽量将相同的部分提到父类// 金庸小说考题试卷class TestPaper{ public function TestQuestion1() { echo \"杨过说过，后来给了郭靖，炼成倚天剑、屠龙刀的玄铁可能是［］a.球磨铸铁 b.马口铁 c.高速合金钢 d.碳素纤维 \\n\"; echo \"答案 \".$this-&gt;answer1().\"\\n\"; } public function TestQuestion2() { echo \"杨过、程英、陆无双铲除了情花，造成［］a.使这种植物不在害人 b.使一种珍惜物种灭绝 c.破坏了那个生态圈的生态平衡 d.造成该地区沙漠化 \\n\"; echo \"答案 \".$this-&gt;answer2().\"\\n\"; } public function TestQuestion3() { echo \"蓝凤凰致使华山师徒、桃谷六仙呕吐不止，如果你是大夫，会给他们开什么药［］a.阿司匹林 b.牛黄解毒片 c.氟哌酸 d.让他们喝大量的生牛奶 e.以上全不对 \\n\"; echo \"答案 \".$this-&gt;answer3().\"\\n\"; } protected function answer1() { return ''; } protected function answer2() { return ''; } protected function answer3() { return ''; }}// 学生甲抄的试卷class TestPaperA extends TestPaper{ protected function answer1() { return 'a'; } protected function answer2() { return 'b'; } protected function answer3() { return 'c'; } }// 学生乙抄的试卷// 学生甲抄的试卷class TestPaperB extends TestPaper{ protected function answer1() { return 'd'; } protected function answer2() { return 'c'; } protected function answer3() { return 'a'; } }// 客户端代码echo \"学生甲抄的试卷: \\n\";$student = new TestPaperA();$student-&gt;TestQuestion1();$student-&gt;TestQuestion2();$student-&gt;TestQuestion3();echo \"学生乙抄的试卷: \\n\";$student2 = new TestPaperB();$student2-&gt;TestQuestion1();$student2-&gt;TestQuestion2();$student2-&gt;TestQuestion3();","tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://lpower.com/tags/设计模式/"}]},{"title":"正则表达式","date":"2019-08-14T09:14:10.000Z","path":"2019/08/14/正则表达式/","text":"正则表达式是学习PHP的基础之一 元字符 元字符 描述 . 匹配任意单个字符除了换行符 [] 匹配方括号内的任意字符 [^] 否定的字符种类，匹配除了方括号里的任意字符 * 匹配&gt;=0个重复的*号之前的字符 + 匹配&gt;=1个重复的+号之前的字符 ？ 标记？之前的字符为可选 ^ 从开始行开始匹配 $ 从末端开始匹配 {}号 在正则表达式中{}是一个量词，常用来一个或一组字符可以重复出现的次数。例如，表达式[0-9]{2,3}匹配最少2位最多3位0-9的数字 (…)特征标群 特征标群是一组写在(…)中的子模式。例如，表达式(ab)*匹配连续出现0或更多个ab 简写字符集 简写 描述 . 除换行符外的所有字符 \\w 匹配所有字母数字 \\W 匹配所有非字母数字 \\d 匹配数字 \\D 匹配非数字 \\s 匹配所有空格字符，等同于：[\\t\\n\\f\\r\\p{Z}] \\S 匹配所有非空格字符 \\f 匹配一个换页符 \\n 匹配一个换行符 \\r 匹配一个回车符 \\t 匹配一个制表符 \\v 匹配一个垂直制表符 \\p 匹配 CR/LF (等同于 \\r\\n)，用来匹配 DOS 行终止符 标志 标志也叫模式修正符，因为它可以用来修改表达式的搜索结果 标志 描述 i 忽略大小写 g 全局搜索 m 多行的: 锚点元字符 ^ $ 工作范围在每行的起始","tags":[{"name":"正则","slug":"正则","permalink":"http://lpower.com/tags/正则/"}]},{"title":"java笔记","date":"2019-07-16T03:53:17.000Z","path":"2019/07/16/java笔记/","text":"Java是一门面向对象编程语言。一个Java程序可以认为是一系列对象的集合，而这些对象通过调用彼此的方法来协同工作。 基本语法 大小写敏感 类名首字母大写，如果类名由多个单词组成，那么每个单词的首字母应该大写 所有的方法名都应该以小写字母开头。如果方法名含有若干单词，则后面的每个单词首字母大写 原文件名必须和类名相同 所有的Java程序由public static void main(String []args)方法开始执行 Java标识符(Java所有的组成部分都需要名字。类名、变量名及方法名都被称为标识符) 所有的标识符都应该以字母，$，或者下划线开始 首字符以后可以是字母，美元符，下划线或数字的任何字符组合 关键字不能做标识符 标识符大小写敏感 Java增强for循环 Java5引入了一种主要用于数组的增强型for循环，语法格式如下：1234for(声明语句:表达式){ //代码句子} 声明语句：声明新的局部变量，该变量的类型必须和数组元素的类型匹配。其作用域限定在循环语句块，其值与此时数组元素的值相等。 表达式：表达式是要访问的数组名，或者是返回值为数组的方法 Spring Boot 约定优于配置 优点 创建独立的spring应用程序 嵌入的Tomcat、Jetty或者Undertow，无需部署WAR文件 允许通过Maven来根据需要获取starter 尽可能的自动配置Spring 提供生产就绪型功能，如指标、健康检查和外部配置 绝对没有代码生成，对XML没有要求配置 IOC （Inversion of Control） 控制反转容器 是Spring的核心，是一种通过描述来获取或者生成对象的技术 功能 通过描述管理Bean，包括发布和获取Bean （在Spring中把每一个需要管理的对象称为Bean） 通过描述完成Bean之间的依赖关系 注解 @ComponentScan 扫描当前类所在的包和子包 @Filter的类型及意义 1234ANNOTATION:注解类型ASSIGNABLE_TYPE:ANNOTATION:指定的类型REGEX:按照正则表达式CUSTOM:i定义规则 @Configurable 表示是Java的配置文件 @Bean 将此方法返回的 POJO 装配到 IoC 容器中，而其属性 name 定义这个 Bean 的名称，如果没有配置它，则将方法名称作为 Bean 的名称保存到 Spring IoC 容器中 。 @SpringBootApplication 是一个复合注解，包括@ComponentScan，和@SpringBootConfiguration，@EnableAutoConfiguration @Component //表明这个类将被 Spring IoC 容器扫描装配 @Autowired //根据属性的类型（by type）找到对应的 Bean 进行注入，＠Autowired 提供这样的规则， 首先它会根据类型找到对应的 Bean, 如果对应类型的 Bean 不是唯一的，那么它会根据其属性名称和 Bean 的名称进行匹配。如果匹配得上，就会使用该 Bean：如果还无法匹配，就会抛出异常。 @Primary //消除歧义性，修改优先权 ＠Quelifier 与＠Autowired 组合在一起，通过类型和名称一起找到 Bean @Override 重写，验证下面的方法名是否是你父类中所有的 @Conditional 只有在特定条件满足时才启用一些配置 @ImportResource ，通过它可以引入对应的 XML 文件，用以加载Bean ＠Aspect 当以此为注解时，spring就会知道这是一个切面，然后我们就可以通过各类注解来定义各类的通知了 ＠Repository 在将来讨论扫描加载MyBatis接口Bean时是十分有用的 @Responsebody 该方法的返回结果直接写入HTTP response body中，一般在异步获取数据时使用 DI （Dependency Injection） 依赖注入 例如，人类（ Person ）有时候利用一些动物 (Animal）去完成一些事情，比方说狗（Dog）是用来看门的，猫（Cat）是用来抓老鼠的， 鹦鹉（Paηot)是用来迎客的……于是做一些事情就依赖于那些可爱的动物了 生命周期 生命周期： 约定编程 AOP（面向切面编程）可以解决对数据库事务的管控问题，还可以减少大量重复的工作。使用Spring AOP可以处理一些无法使用 OOP 实现的业务逻辑。其次，通过约定，可以将一些业务逻辑织入流程中，并且可以将一些通用的逻辑抽取出来，然后给予默认实现，这样你只需要完成部分的功能就可以了，这样做可以使得开发者的代码更加简短，同时可维护性也得到提高。 JPA（Hibernate）操作数据 Java持久化API，是定义了对象关系映射（ORM）以及实体对象持久化的标准接口。JPA所维护的核心是实体，而它是通过持久化上下文来使用的。持久化上下文包含以下三个部分： 对象关系映射，主要通过注解实现 实体操作API，实现对实体对象的CRUD操作，来完成对象的持久化和查询 查询语言，约定了面向对象的查询语言JPQL，通过这层关系可以实现比较灵活地查询 MyBatis 定义：MyBatis是支持定制化SQL、存储过程以及高级映射的优秀的持久层框架。 MyBatis避免了几乎所有的JDBC代码和手动设置参数以及获取结果集。MyBatis 可以对配置和原生Map使用简单的XML或注解，将接口和Java的POJO ( Plain Old Java O均ect，普通的 Java 对象）映射成数据库中的记录。 配置内容 properties（属性） settings（设置）：改变Mybatis的底层行为 typeAliases（别名） typeHandles（类型处理器）：是重要配置之一，在写入和读取数据库的过程中对于不同类型的数据进行自定义转换 plugins(插件)：也称拦截器，是最强大也是最危险的组件。通过动态代理和责任链模式完成，可以修改底层上的实现功能 mappers（映射器）是最核心的组件，提供SQL和POJO的映射关系，是Mybatis开发的核心","tags":[{"name":"Java基础","slug":"Java基础","permalink":"http://lpower.com/tags/Java基础/"}]},{"title":"ubuntu16.04下搭建lnmp","date":"2019-06-12T05:39:35.000Z","path":"2019/06/12/ubuntu16-04-下搭建lnmp/","text":"记一次Linux下搭建lnmp环境走过的坑 更新源sudo apt-get update 安装nginx 123sudo apt-get install nginxsudo service nginx start //开启nginx服务systemctl status nginx //查看nignx状态 在浏览器输入127.0.0.1，出现如下界面，说明已经安装成功 安装php7.1与php7.1-fpm 直接运行sudo apt-get命令安装PHP会报错，原因是 PHP7 等并不在 Ubuntu的软件库中，因此要使用 PPA ppa:ondrej/php 库，所以需要运行如下命令： 123sudo apt-add-repository ppa:ondrej/phpsudo apt-get updatesudo apt-get install php7.1 php7.1-fpm 安装完成后运行php -v命令查看php版本，确定php安装完成 安装MySQL及PHP-MySQL扩展 1apt-get install mysql-server mysql-client php7.1-mysql 安装过程中会需要输入MySQL的密码，输入自己想要设置的密码即可。安装完成后，运行systemctl start mysql开启MySQL服务 Nginx 与 PHP-FPM集成 修改nginx配置文件 nginx配置文件在/etc/nginx/sites-available/default 配置文件中（网站根目录也在是这里更改）,nginx已经默认与php-fpm集成好了，只需修改以下配置即可 123456789root /var/www/html //网站默认根目录index index.php index.html index.htm index.nginx-debian.html;//默认文件location ~ \\.php$ { include snippets/fastcgi-php.conf; # # With php7.0-cgi alone: # fastcgi_pass 127.0.0.1:9000; # # With php7.0-fpm: fastcgi_pass unix:/run/php/php7.1-fpm.sock;} 配置完成后，保存退出。运行nginx -t命令检测配置文件是否有错误。我在检测的时候遇到了一个错误 这种情况是80端口被占用，此时我们可以输入lsof -i :80命令来查看80端口的pid，然后kill pid号将进程关闭，再运行nginx -t，如果出现 证明配置完成，再重新载入nginx配置（nginx -s reload） 完成搭建 改完配置文件后，重新启动nginx服务systemctl start nginx,此时可能会报错，查看nginx状态systemctl status nginx，会发现出现下列情况 这个错误还是端口80被占用，用上述方法再修复一次即可。 启动php-fpm服务 systemctl start php7.1-fpm sudo echo '&lt;?php echo phpinfo();' &gt; /var/www/html/test.php运行此命令，将test.php存放到网站根目录下，访问127.0.0.1/test.php，如果成功，会出现 .但是注意，这里还会有一个坑，访问这个页面之后可能会出现502的情况，如果出现502，应该就是nginx配置文件出错location ~ \\.php$ { include snippets/fastcgi-php.conf; # # With php7.0-cgi alone: # fastcgi_pass 127.0.0.1:9000; # # With php7.0-fpm: fastcgi_pass unix:/run/php/php7.1-fpm.sock; } 仔细看这个配置文件最后一行，php的版本一定要与自己系统里的php版本一样，如果是7.2，就要改为7.2，否则就会出现502错误。改完以后，重新载入配置，启动服务，在测试一遍，就会成功。","tags":[{"name":"环境搭建","slug":"环境搭建","permalink":"http://lpower.com/tags/环境搭建/"}]},{"title":"phpdbg","date":"2019-06-10T05:35:50.000Z","path":"2019/06/10/phpdbg/","text":"phpdbg是一个PHP的SAPI模块，可以在不用修改代码和不影响性能的情况下控制PHP的运行环境 phpdbg的目标是成为一个轻量级，强大，易用的PHP调试平台。可以在PHP5.4及以上版本使用，在PHP5.6及以上版本已经内置使用方法以下面的代码为例：12345678910111213141516&lt;?phpfunction test($a,$b){ $c = $a + $b; return $c;}$i = 1;$j = 2;echo test($i,$j),PHP_EOL;$name = '白菜';class TestClass{ public function printSth($a){ echo $a.'----'; }}$test = new TestClass();$test-&gt;printSth('123'); 如果想要加载要调试的脚本，只需执行exec命令即可，如下： 显示successful即成功。当然我们也可以在启动的时候指定e参数： 设置断点 按opline设置断点：这里所说的opline，就是以方法入口作为起点，当前所在代码的行号。在上面的示例中，第三行的’$c = $a + $b;’的opline就是1. 执行：可以看到断点执行情况 按方法设置断点 按行数设置断点 查看断点 info break的显示结果中会把断点的类型也给显示出来。#后面的数字是断点号，我们可以根据断点号删除断点 删除断点 单步执行 phpdbg的单步执行只有一个命令 step。是一行一行的执行代码。 继续执行 continue继续执行代码，简写为c 查看代码 list命令显示test函数的代码 查看opcode print 命令查看opcode","tags":[{"name":"调试","slug":"调试","permalink":"http://lpower.com/tags/调试/"}]},{"title":"redis命令","date":"2019-04-20T08:10:55.000Z","path":"2019/04/20/redis命令/","text":"redis常用命令 redis键 del key //删除key dump key //序列化给定key，并返回被序列化的值 exists key //检查key是否存在 expire key seconds/timestamp //设置过期时间，以秒/Unix时间戳计 keys pattern //查找所有符合给定模式的key move key DB //将当前数据库的key移动到给定的数据库db当中 persist key //移除key的过期时间，key将持久保持 rename key newkey //修改key的名称 字符串 set key value //设置指定key的值 get key //获取指定key的值 getrance key start end //返回key中字符串值的子字符 getset key value //将给定的值设为value，并返回key的旧值 getbit key offset //对key所储存的字符串值，获取指定偏移量上的位 mget key1 //获取所有给定的值 strlen key //返回key所储存的字符串值的长度 mset key value //同时设置一个或多个key-value对 append key value //如果 key 已经存在并且是一个字符串， APPEND 命令将指定的 value 追加到该 key 原来值（value）的末尾。 哈希 Redis hash 是一个string类型的field和value的映射表，hash特别适合用于存储对象。 hmset key value //创建一个哈希表 hdel key field1 [field2] //删除一个或多个哈希表字段 hexists key field //查看哈希表中指定的字段是否存在 hget key field //获取在哈希表中指定key的所有字段和值 hincrby key field increment //为key中的指定字段的整数值加上增量increment hkeys key //获取所有哈希表中的字段 hlen key //获取哈希表中字段的数量 hvals key //获取哈希表中所有值 hset key field value //将哈希表中的字段field的值设为value 列表 ：是简单的字符串列表，按照插入顺序排序，你可以添加一个元素到列表的头部或者尾部 lpush key value //将value值插入key列表中 blpop key1 timeout //移出并获取列表的第一个元素， 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。3.BRPOP key1 timeout //移出并获取列表的最后一个元素， 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。 lindex key index //通过索引获取列表中的元素 linsert key before|after pivot value //在列表的元素前或后插入元素 llen key //获取列表长度 lpop key //移出并获取列表的第一个元素 lpush key value //将一个值插入到已存在的列表头部 lrem key count value //移除列表元素 rpushx key value //为已存在的列表添加值 集合：Redis 的 Set 是 String 类型的无序集合。集合成员是唯一的，这就意味着集合中不能出现重复的数据。Redis 中集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是 O(1)。 sadd key member1 //向集合添加一个或多个成员 scard key //获取集合的成员数 sdiff key1 //返回给定所有集合的差集 sinter key1 //返回给定所有的交集 sismember key member //判断member元素是否是集合key的成员 spop key //移除并返回集合中的一个随机元素","tags":[{"name":"redis","slug":"redis","permalink":"http://lpower.com/tags/redis/"}]},{"title":"php文件上传","date":"2019-04-19T06:53:58.000Z","path":"2019/04/19/php文件上传/","text":"PHP实现文件上传 _FILES $_FILES是PHP的全局数组，可以上传文件。第一个参数是文件名，第二个参数可以使如下所示的几个： 12345$_FILES[\"file\"][\"name\"] - 上传文件的名称$_FILES[\"file\"][\"type\"] - 上传文件的类型$_FILES[\"file\"][\"size\"] - 上传文件的大小，以字节计$_FILES[\"file\"][\"tmp_name\"] - 存储在服务器的文件的临时副本的名称$_FILES[\"file\"][\"error\"] - 由文件上传导致的错误代码 错误代码各值所代表的意思： 1234567UPLOAD_ERR_OK //其值为 0，没有错误发生，文件上传成功。 UPLOAD_ERR_INI_SIZE //其值为 1，上传的文件超过了 php.ini 中 upload_max_filesize 选项限制的值。 UPLOAD_ERR_FORM_SIZE //其值为 2，上传文件的大小超过了 HTML 表单中 MAX_FILE_SIZE 选项指定的值。 UPLOAD_ERR_PARTIAL //其值为 3，文件只有部分被上传。 UPLOAD_ERR_NO_FILE //其值为 4，没有文件被上传。 UPLOAD_ERR_NO_TMP_DIR //其值为 6，找不到临时文件夹。PHP 4.3.10 和 PHP 5.0.3 引进。 UPLOAD_ERR_CANT_WRITE //其值为 7，文件写入失败。PHP 5.1.0 引进。 move_uploaded_file move_uploaded_file函数，将上传的文件移动到新的位置。 说明：move_uploaded_file( string $filename, string $destination) : bool,本函数检查并确保由 filename 指定的文件是合法的上传文件（即通过 PHP 的 HTTP POST 上传机制所上传的）。如果文件合法，则将其移动为由 destination 指定的文件。 这种检查显得格外重要，如果上传的文件有可能会造成对用户或本系统的其他用户显示其内容的话。 参数：filename 上传的文件名 destination 要移动到的位置 文件上传表单 123456789101112131415&lt;html&gt;&lt;head&gt;&lt;meta charset=\"utf-8\"&gt;&lt;title&gt;lpower&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=\"upload_file.php\" method=\"post\" enctype=\"multipart/form-data\"&gt; &lt;label for=\"file\"&gt;文件名：&lt;/label&gt; &lt;input type=\"file\" name=\"file\" id=\"file\"&gt;&lt;br&gt; &lt;input type=\"submit\" name=\"submit\" value=\"提交\"&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 注意： 标签的 enctype 属性规定了在提交表单时要使用哪种内容类型。在表单需要二进制数据时，比如文件内容，请使用 “multipart/form-data”。 上传脚本 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;?php// 允许上传的图片后缀$allowedExts = array(\"gif\", \"jpeg\", \"jpg\", \"png\");$temp = explode(\".\", $_FILES[\"file\"][\"name\"]);echo $_FILES[\"file\"][\"size\"];$extension = end($temp); // 获取文件后缀名if ((($_FILES[\"file\"][\"type\"] == \"image/gif\")|| ($_FILES[\"file\"][\"type\"] == \"image/jpeg\")|| ($_FILES[\"file\"][\"type\"] == \"image/jpg\")|| ($_FILES[\"file\"][\"type\"] == \"image/pjpeg\")|| ($_FILES[\"file\"][\"type\"] == \"image/x-png\")|| ($_FILES[\"file\"][\"type\"] == \"image/png\"))&amp;&amp; ($_FILES[\"file\"][\"size\"] &lt; 204800) // 小于 200 kb&amp;&amp; in_array($extension, $allowedExts)){ if ($_FILES[\"file\"][\"error\"] &gt; 0) { echo \"错误：: \" . $_FILES[\"file\"][\"error\"] . \"&lt;br&gt;\"; } else { echo \"上传文件名: \" . $_FILES[\"file\"][\"name\"] . \"&lt;br&gt;\"; echo \"文件类型: \" . $_FILES[\"file\"][\"type\"] . \"&lt;br&gt;\"; echo \"文件大小: \" . ($_FILES[\"file\"][\"size\"] / 1024) . \" kB&lt;br&gt;\"; echo \"文件临时存储的位置: \" . $_FILES[\"file\"][\"tmp_name\"] . \"&lt;br&gt;\"; // 判断当期目录下的 upload 目录是否存在该文件 // 如果没有 upload 目录，你需要创建它，upload 目录权限为 777 if (file_exists(\"upload/\" . $_FILES[\"file\"][\"name\"])) { echo $_FILES[\"file\"][\"name\"] . \" 文件已经存在。 \"; } else { // 如果 upload 目录不存在该文件则将文件上传到 upload 目录下 move_uploaded_file($_FILES[\"file\"][\"tmp_name\"], \"upload/\" . $_FILES[\"file\"][\"name\"]); echo \"文件存储在: \" . \"upload/\" . $_FILES[\"file\"][\"name\"]; } }}else{ echo \"非法的文件格式\";}?&gt; 服务器的 PHP 临时文件夹中创建了一个被上传文件的临时副本,要保存上传的文件，要拷贝到upload文件下。","tags":[{"name":"代码","slug":"代码","permalink":"http://lpower.com/tags/代码/"}]},{"title":"linux下配置与使用Redis","date":"2019-04-17T09:05:31.000Z","path":"2019/04/17/linux下使用Redis/","text":"突然发现自己的非关系型数据库的知识几近于无，因此就想学习一点这方面的知识 NoSQL 又称非关系型数据库。NoSQL有时也称作Not Only SQL的缩写，是对不同于传统的关系型数据库的数据库管理系统的统称。NoSQL用于超大规模数据的存储。这些类型的数据存储不需要固定的模式，无需多余操作就可以横向扩展。 优点：高可扩展性，分布式计算，成本低，具有灵活的架构，半结构化数据，无复杂关系 Redis 非关系型数据库中的一种，完全开源免费，是一个高性能的key-value数据库 特点： Redis支持数据的持久化，可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用。 Redis不仅仅支持简单的key-value类型的数据，同时还提供list，set，zset，hash等数据结构的存储。 Redis支持数据的备份，即master-slave模式的数据备份。 优势： 性能高，读的速度为110000次/s，写的速度是81000次/s 丰富的数据类型，支持 Strings, Lists, Hashes, Sets 及 Ordered Sets 数据类型操作。 原子性，单个操作是原子性的。多个操作也支持事务，即原子性，通过MULTI和EXEC指令包起来。 丰富的特性，支持 publish/subscribe, 通知, key 过期等等特性。 Linux下配置Redis环境（PHP） 首先需要一个Linux环境，我用的是虚拟机，系统是centos7 修改防火墙配置 12345vim /etc/sysconfig/iptables//在里面写入需要开放的端口-A INPUT -m state --state NEW -m tcp -p tcp --dport 80 -j ACCEPT（允许Apache80端口通过防火墙） -A INPUT -m state --state NEW -m tcp -p tcp --dport 3306 -j ACCEPT（允许PHP3306端口通过防火墙）-A INPUT -m state --state NEW -m tcp -p tcp --dport 6379 -j ACCEPT（允许redis6379端口通过防火墙） 之后重启防火墙systemctl restart firewalld.service，使服务生效。 安装Apache：执行以下命令 123yum install httpd //yum安装Apachesystemctl start httpd.service //启动httpd服务systemctl enable httpd.service //设置开机自启 安装PHP：执行以下命令 12345678yum install php //安装PHPsystemctl start php-fpm //开启PHP服务cd /var/www/html // 切换到www路径，写一下测试vim index.php //这里随便起名//这里是测试用例&lt;?phpphpinfo();? 写完以后，确保Apache服务是开启的，可以执行systemctl status httpd这个语句来确定Apache的状态，如果是running，证明是开启的。然后去浏览器里输入localhost/index.php，如果出现以下的结果，证明安装成功。 安装Redis：执行以下命令 123456yum install redisyum install epel-releaseyum install redissystemctl start redissystemctl status redissystemctl enable redis Redis配置,可以直接修改配置文件，也可以在命令行里修改。 1234567redis-cli -h 127.0.0.1 -p 6379 //redis端口号6379，本地登录//查看配置config get * //查看所有配置//为redis设置密码config set requirepass 'password' auth passwordconfig get requirepass 设置完密码后，重新登陆。如果不输入密码，当你输入命令后，会提示报错。因此当你登录进去后，首先要输入auth password才能继续使用。当然，也可以在登录时直接输入密码，命令是redis-cli -h 127.0.0.1 -p 6379 -a password，这样登陆进去之后就可以直接使用。 查看全部配置： php与redis 首先，需要安装PHP扩展yum install php-pecl-redis 然后，修改php配置文件 1vim /etc/php.ini //编辑配置文件 如果找不到php.ini,可以使用whereis命令，在配置文件最后，添加extension=redis.so,保存并退出。 测试：去Apache目录下vim一个测试文件 1234567891011cd /var/www/htmlvim test.php&lt;?php//连接本地的 Redis 服务$redis = new Redis();$redis-&gt;connect('127.0.0.1', 6379);$redis-&gt;auth('password');echo \"Connection to server successfully\"; //查看服务是否运行echo \"Server is running: \" . $redis-&gt;ping();?&gt; 成功之后，会输出Connection to server successfullyServer is running: +PONG 这样就代表我们能够使用PHP操作Redis了。","tags":[{"name":"redis","slug":"redis","permalink":"http://lpower.com/tags/redis/"}]},{"title":"php验证码","date":"2019-03-25T08:05:08.000Z","path":"2019/03/25/php验证码/","text":"刚刚看了验证码的实现过程，觉得有必要记一下 实现函数 1) imagecreatefromjpeg() 载入图片 2) imageTTFText() 设置字体颜色 3) imagefill() 填充背景 4) imagejpeg() 创建jpg图片 5) imagedestory() 销毁图片，释放内存空间 代码实现 123456789101112131415161718192021222324252627282930313233343536373839&lt;?php//制作验证码//创建画布$img = imagecreatetruecolor(170, 40);//填充背景色$backcolor = imagecolorallocate($img, 255, 255, 255);//默认红、绿、蓝三色。imagefill($img, 0, 0, $backcolor);//产生随机验证码字符串$arr = array_merge(range(0,9),range('a','z'),range('A','Z'));//array_merge() 将一个或多个数组的单元合并起来，一个数组中的值附加在前一个数组的后面。返回作为结果的数组。shuffle($arr);//打乱数组，伪随机$rand_keys = array_rand($arr,4);$str = '';foreach ($rand_keys as $value) { $str .= $arr[$value]; }//保存到sessionsession_start();$_SESSION['captcha'] = $str;//将获取的随机数验证码写入到session变量中//添加文字$span = floor(170/(4+1));for($i=1;$i&lt;=4;$i++) { $stringcolor = imagecolorallocate($img, mt_rand(0,255), mt_rand(0,100), mt_rand(0,80)); imagestring($img, 5, $i*$span, 12, $str[$i-1], $stringcolor);//水平输出字符}//添加干扰线for ($i=1; $i&lt;=6 ; $i++) { $linecolor = imagecolorallocate($img,mt_rand(0,255),mt_rand(0,100),mt_rand(0,80)); imageline($img,mt_rand(0,169),mt_rand(0,39),mt_rand(0,169),mt_rand(0,39),$linecolor);//设置随机字体和x,y坐标}//添加干扰点for($i=0;$i&lt;strlen($_SESSION['captcha']);$i++){ $pixel = imagecolorallocate($img,mt_rand(100,150),mt_rand(0,120),mt_rand(0,255));//设置背景色 imagesetpixel($img, mt_rand(0,169), mt_rand(0,39), $pixel);//设置随机字体和x,y坐标}//输出图片header(\"Content-type:image/png\");ob_clean();//清理缓冲区imagepng($img);//输出图片imagedestroy($img);//销毁图片 mt_rand()返回随机整数","tags":[{"name":"代码","slug":"代码","permalink":"http://lpower.com/tags/代码/"}]},{"title":"关于http的一些总结","date":"2019-03-19T07:51:29.000Z","path":"2019/03/19/关于http的一些总结/","text":"http在学习网络的过程中是必不可少的，所以在这里整理了一些关于HTTP的知识点 HTTP2与之前的版本的比较 所有数据均以二进制传输 同一个连接里面发送多个请求不再需要按照顺序来 增加了头信息压缩以及推送(并行推送css,html等)等提高效率的功能 HTTP三次握手 SYN:标志位 Seq 随机产生 回应：ACK = Seq+1 客户端发给服务器一个信号(SYN=1,Seq=0)。服务器端收到后，回应给客户端(SYN=1,ACK=1,Seq=0),当客户端收到服务器端的信号后，再回复给客户端，告知自己收到消息(ACK=1,Seq=0)。三次握手完毕后，确认可以安全传输。 功能：防止服务端开启一些无用的连接，减少服务器一些不必要的开销。 URI URL URN URI Uniform Resource Identifier/统一资源标识符 用来唯一标识互联网上的信息资源 包含URL和URN URL Uniform Resource Locator/统一资源定位器 https://www.baidu.com 此类格式的都叫做URL，还有ftp协议等等。 URN 永久统一资源定位符 在资源移动之后还能被找到 http报文 请求部分： 123首行第一部分 method 请求方法 get,post等首行第二部分 url（请求的地址）首行第三部分 协议版本 响应报文： 123首行第一部分 协议版本首行第二部分 code 200表示正常首行第三部分 明文表示code的含义 http方法 用来定义对于资源的操作 GET post等 HTTP CODE ,可以判断结果. 定义服务器对请求的处理结果，各个区间的CODE有各自的意义123456789100-199 代表请求已经被接受，需要继续处理 eg:100 Continue200-299 代表请求已成功被接收，理解并接受 eg:200 OK 202 accepted300-399 代表需要客户端采取进一步的操作才能完成请求，通常用来重定向 eg:307 Temporary Redirect在这种情况下，请求应该与另一个URI重复，但后续的请求应仍使用原始的URI。与302相反，当重新发出原始请求时，不允许更改请求方法。例如，应该使用另一个POST请求来重复POST请求。400-499 代表客户端看起来可能发生了错误 eg:403 forbidden 404 not found500-599 代表服务器错误 eg: 500 502 网关错误 CORS跨域请求的限制与解决 CORS CORS是一个W3C标准，全称是”跨域资源共享”（Cross-origin resource sharing）。 它允许浏览器向跨源服务器，发出XMLHttpRequest请求，从而克服了AJAX只能同源使用的限制。 限制 浏览器同域请求，在浏览器这边发送的Ajax请求必须在同域里，如果跨域，需要服务器同意 请求头限制 解决 可以通过放入Access-Control-Allow-Origin: '*'来实现跨域(‘*’ 代表任何服务都可以跨域 可以设置为一个特定的域名) 在script,link,image标签里写路径，加载一些东西的时候，浏览器是允许跨域的 CORS预请求 除GET,POST,HEAD三种方法 及三种Content-Type(text/plain,multipart/form-data,application/x-www-form-urlencoded)外，其他都需要预请求 cookie和session cookie 在服务端返回数据时，通过Set-Cookie这个head设置在浏览器里面，保存在浏览器里面的一个内容。 下次请求会自动带上 键值对，可以设置多个 有时效，如果没有设置时间，关闭浏览器后就会删除 属性： max-age和expires设置时间 Secure只在http的时候发送 HttpOnly无法通过documents.cookie访问(防止CSRF注入) session 位于web服务器上，主要负责访问者与网站之间的交互 关闭网站时会话结束 无法永久保存数据 cookie与session的区别 session比cookie更安全 cookie在客户端，session在服务器上 cookie能够保存的数据较小","tags":[{"name":"HTTP","slug":"HTTP","permalink":"http://lpower.com/tags/HTTP/"}]},{"title":"实训笔记","date":"2019-01-03T02:26:13.000Z","path":"2019/01/03/实训笔记/","text":"2019年第一篇博客，我大学生涯的第一次实训，在大连诺达，学了一些思科模拟器的使用和一点网络安全基础（防火墙）,使用的是思科的eve 一、交换机和MAC地址 单工，半双工，全双工 单工：数据只能沿一个方向发送，另一个方向是无法发送数据的。 半双工：数据可以沿两个方向发送，但同一时间只可能有一台设备发送数据。 全双工：数据可以沿两个方向同时发送。 TYPE的取值：0800代表IP协议 0806代表arp协议二、iOS软件操作 路由器： 1）首先输入no 初始化配置对话 2） en 进入特权模式 3）configuration terminal 进入全局配置模式 4）hostname xxx 修改主机名 IP地址 1）配置 12345678910step1：进入要配置IP地址的接口。命令：全局配置模式下：interface +接口号step2：配置IP地址命令：接口子配置模式下：ip address IP地址 子网掩码示例：R1(config-if)#ip address 12.1.1.1 255.255.255.0step3：开启接口，因为接口模式情况下是关闭的，即使配置IP地址也无法正常工作，所以需要开启接口。命令：接口子配置模式下：no shutdown示例：R1(config-if)#no shutdownstep4：exit退出接口子配置模式进入另一个接口。step5：检查IP地址配置 命令：特权模式下：show ip interface brief显示接口的三层摘要信息。在除了执行模式外其它模式输入执行命令时，需要在命令前添加do 关键字。 检查IP地址配置是否无误，使用ping命令，来检查一对直连接口的IP 。 2）分类 IP地址根据其使用的方式分为ABCDE5类。分类的依据是一个IP地址当中前4bit的取值情况，按照如下规则进行分类。 12345A：0xxx B：10xxC：110xD：1110 组播IP地址E：1111 保留科研用IP地址 A类地址的范围为1~126。0为保留地址。127为本地环回地址。B类地址的范围为128~191。169.254为本地链路地址，DHCP获取地址失败时会使用该地址。C类地址的范围为192~223。本地广播地址：255.255.255.255（也就是32个1） 网络位：标识主机所属的网络 主机位：标识网络中的一台主机 3）封装与解封 IP首部12345678910111213版本（4bit）：描述IP协议版本。一般为4。IHL（4bit）：描述IP协议首部长度。ToS（8bit）：用于标记流量，用作QoS。总长度（16bit）：代表一个IP数据包的总长度。标识（16bit）：相同的标识代表分片数据包属于同一个源数据包。标志（3bit）：0（保留，恒为0）0（DF位，禁止分片位）0（MF更多分片位）片偏移（13bit）：当前分片的第一个bit与原始分片的第一个bit的相对位移。MTU：最大传输单元，默认情况下多为1500TTL（8bit）：当TTL为0时，该数据包将被丢弃。用于减缓产生路由环路后对网络的影响。协议（8bit）：用于指示IP报文的上层协议。（例：TCP 6，UDP 17，ICMP 1）首部校验和（16bit）：检查IP首部在传输过程当中的完整性。源IP地址（32bit）：源主机IP地址目的IP地址（32bit）：目的主机IP地址 三、传输层（tcp，udp，arp，路由表） telnet协议（远程管理协议） 实验配置：12345678910111213141516171819PC配置Router(config)#hostname PC //将路由器的主机名设置为PCPC(config)#int e0/0 //进入设备的e0/0接口子配置模式PC(config-if)#ip address 12.1.1.1 255.255.255.0 //设置e0/0接口的IP地址为12.1.1.1/24PC(config-if)#no sh //开启e0/0接口PC(config)#no ip routing //关闭路由器的路由功能PC(config)#ip default-gateway 12.1.1.2 //设置路由器的默认网关（备注：用路由器模拟PC的时候，必须关闭路由器的路由功能并为它设置默认网关。因为一台路由器收到一个目的地址未知的数据包，就会将它丢弃。而主机收到一个目的地址未知的数据包，会把它交给自己的网关）路由器的配置Router(config)#hostname ROUTER //将路由器的主机名设定为ROUTERROUTER(config)#int e0/0 //进入e0/0接口的子配置模式ROUTER(config-if)#ip address 12.1.1.2 255.255.255.0 //设置e0/0接口的IP地址为12.1.1.2/24ROUTER(config-if)#no sh //开启e0/0接口ROUTER(config)#line vty 0 4 //开启虚拟终端线路0到4共5条ROUTER(config-line)#transport input telnet //限制入方向只能通过TELNET进行连接ROUTER(config-line)#password cisco123 //配置线路密码ROUTER(config-line)#login //开启线路下密码认证功能验证实验效果PC&gt;telnet 12.1.1.2 //使用telnet协议连接12.1.1.2主机，默认端口号23。 路由表 查看路由器的路由表：show ip route 1234C 10.1.10.0/24 is directly connected, Ethernet0/0L 10.1.10.254/32 is directly connected, Ethernet0/0C 10.1.20.0/24 is directly connected, Ethernet0/1L 10.1.20.254/32 is directly connected, Ethernet0/1 路由表中的每个路由条目，以一个网络地址作为主项。 最前面的代码，一般是一个大写字母，代表一个路由表项的来源，常见来源： 123456 C 直连路由L 本地路由D EIGRP路由R RIP路由S 静态路由O OSPF路由 一条路由可能在最后带有一个出接口。代表去往该网络需要将数据从出接口转发出去。有些路由没有出接口。没有出接口的路由一定会带有下一跳路由器信息，根据该信息可以进行路由的递归查询。 一条路由可能在最后带有一个下一跳，代表去网该网络需要将数据发往哪个主机。 一条路由（除了直连），一定会带有一个方括号，里面包含一对儿数字，其中前面的数字为AD（管理距离）后面的数字叫Metric(度量)。 管理距离代表路由器对某种路由来源的信任程度。越小越好。常见管理距离，直连路由为0，静态路由默认为1，EIGRP为90，OSPF为110，RIP为120。管理距离越小，路由器越信任某种路由。 度量代表路由协议通过何种方式计算到达目标网络的距离。也是越小越好。常见的度量标准有带宽（OSPF），跳数（RIP）和综合度量值（EIGRP）。目前的情况来看带宽是对数据传输能力影响最大的参数，所以推荐使用以带宽作为度量标准的路由协议（OSPF和ISIS和EIGRP）。 arp（地址解析协议） 1）0x0806对应ARP协议 2）ARP请求报文中的关键字段： 源协议地址：发送主机的IP地址 目的协议地址：目标主机的IP地址 源硬件地址：发送主机的MAC地址 目的硬件地址：00-00-00-00-00-00 如果主机收到一个ARP请求，其中的目的协议地址是自己的IP地址，则他会向发来ARP请求的主机发送ARP回复。ARP回复是单播发送的 四、路由基础 静态路由 静态路由配置 R1(config)#ip route 10.1.2.0 255.255.255.0 12.1.1.2 配置一条到达10.1.2.0/24的路由，下一跳路由器接口IP地址为12.1.1.2。 配置静态路由一定要注意，下一跳接口地址必须可达。否则该静态路由不会装载进路由表。 配置静态路由一定要注意单向路由问题。一个单向路由是没有意义的 默认路由 R1(config)#ip route 0.0.0.0 0.0.0.0 12.1.1.2 配置一条指向12.1.1.2的静态默认路由。 默认路由是一种特殊的路由，它的前缀长度为0。所以默认路由可以被理解为描述一个最大的网络的路由，该网络可以包含任何一个IP网络。在末节路由器上常常配置默认路由来减少路由配置的复杂度。只要拥有任何一条明细路由，数据便不会匹配默认路由进行转发，这是由于路由表拥有最长子网掩码匹配的特性。任何明细路由子网掩码长度都会比默认路由的0更长一些，所以在有明细路由的情况下，数据不会匹配默认路由进行发送。 五、icmp（互联网控制协议） IP协议号 1 校验和与IP和TCP/UDP校验和一样用于检查数据的完整性。 类型用于表明该ICMP报文属于什么类型。 代码用于表明该ICMP报文属于某种类型的子类型。 大部分ICMP类型的报文我们目前已经停止使用了。现在还在频繁使用的ICMP类型有： ICMP 类型8：回显请求。PING命令用于控制一台设备发送一个回显请求到某一个特定主机。收到回显请求的主机必须用回显应答进行响应。如果对端主机无法在规定时间内对回显请求进行响应，通常说明本主机与目标主机存在IP连通性故障。 ICMP类型0：回显应答。在收到某主机发送过来的回显请求后，必须用回显应答对对端主机进行响应。这说明对端主机正在测试与本主机之间的IP连通性。 ICMP类型3：差错报告报文。当一个主机由于某种原因丢弃了一个IP数据包后，会使用差错报告报文通知该数据包的源IP地址。根据不同的丢包原因，设定不同的CODE。常见丢包原因有：主机不可达，网络不可达，端口不可达等。六、vlan（虚拟局域网） 配置 123456789VLAN配置命令Switch(config)#vlan 10创建一个VLAN号为10的VLANSwitch(config-vlan)#name HR将某个VLAN的名字改为HRSwitch(config-if)#switchport mode access将该接口的模式配置为accessSwitch(config-if)#switchport access vlan 10将该接口分配到VLAN10中 trunk 1234567配置命令：SW1(config-if)#switchport trunk encapsulation dot1q将接口的Trunk封装修改为802.1qSW1(config-if)#switchport mode trunk将接口的模式修改为TrunkSW1#show interfaces trunk查看一台交换机接口的trunk情况 vtp 123456789VTP基本配置SW1(config)#vtp mode server将交换机配置为VTP服务器SW1(config)#vtp mode client将交换机配置为VTP客户端SW1(config)#vtp mode transparent将交换机配置为VTP透明模式SW1(config)#vtp domain CCNA配置VTP域名为CCNA 七、DHCP（动态主机配置协议） DHCP分4次握手从服务器获取一个IP地址。 12341 客户端发送一个DISCOVER报文。（广播）2 服务器回应一个OFFER报文。（单播）3 客户端发送一个REQUEST报文。（广播）4 服务器回应一个ACK报文。（单播） 4次握手之后，IP地址被正常的分配给客户端使用。 123456789ip dhcp pool VLAN10network 10.1.10.0 255.255.255.0default-router 10.1.10.254 ip dhcp pool VLAN20network 10.1.20.0 255.255.255.0default-router 10.1.20.254 ip dhcp pool VLAN30network 10.1.30.0 255.255.255.0default-router 10.1.30.254 安全方向八、ACL-访问控制列表 概念 访问控制列表是一种工具。顾名思义，它是一个列表。该列表有非常广泛的用途是各个厂商的安全设备或安全方案中的一个基本组件。该列表最初的作用在于控制访问，后来根据不同的应用场景，发展出不同的作用并衍生出各种其他的策略工具。 基本操作 ACL是一系列包含了permit或deny操作以及对应的条件的有序语句。整个ACL的工作过程如下：自顶向下对每条ACL语句进行评估，一旦发现条件匹配的情况则应用相对应的操作并停止继续向下匹配后续语句。所谓的顶和下是通过ACL的序号来决定的。序号越小，越优先匹配，序号越大匹配的顺序越靠后。 所有ACL的末尾，都存在一个deny any的ACL语句。它的序号相当于无限大，也就是说任何用户定义的ACL都将优先于它进行匹配，也就是说如果一个数据没有被任何用户定义的ACL匹配，则它一定会被末尾的deny any语句匹配，并且流量会被拒绝。一方面默认的deny any操作体现了安全策略的基本原则，另一方面要注意，在编辑一个黑名单时，一定要在整个ACL的末尾，明确的permit any。否则，一个所有操作均为deny的ACL是没有实际意义的。 分类 标准ACL：只能以数据的源IP地址作为条件匹配流量。 扩展ACL：可以以数据的源IP，目的IP以及其它一些三层和四层报文内容作为条件匹配流量。我们比较常用的是扩展ACL。 配置 ACL配置： 12345678R3(config)#access-list 1 deny 10.1.3.0 0.0.0.255 //定义一个编号的标准ACL，拒绝10.1.3.0/24为源的数据R3(config)#access-list 1 permit any//定义一个编号的标准ACL，放行所有流量R3(config-if)#ip access-group 1 out //将编号ACL 1 调用在该接口的出方向上（注意配置模式）R3#show ip access-lists//检查配置的ACL以及命中情况。 命名的扩展ACL配置： 123456R3(config)#ip access-list extended DENYHR2SRV//配置一个名为DENYHR2SRV的扩展ACLR3(config-ext-nacl)# deny ip 10.1.2.0 0.0.0.255 10.1.100.0 0.0.0.255//拒绝从10.1.2.0/24去往10.1.100.0/24的所有IP流量R3(config-ext-nacl)# permit ip any any//放行所有其它流量 九、NAT（网络地址转换） 由来 IPv4地址资源十分有限，总数只要43亿个左右，而且有大量地址是保留的无法直接分配给主机使用。随着互联网以及物联网的不断发展，接入到互联网中的设备数量越来越多。每一个需要在互联网上通信的设备都需要一个IP地址才能正常工作。私有IP地址的使用不受任何限制，也无需向IANA申请，但私有IP地址在Internet上是不被路由的，因为它破坏了IP地址唯一标识一台互联网主机的特点。在这种情况下，我们想要正常使用互联网资源，需要借助NAT技术。 静态nat配置 问题:配置静态NAT。马同学家里有运营商分配的合法IP地址12.1.1.1和12.1.1.3。12.1.1.1被配置在TP-LINK路由器的公网接口e0/1上。现在要求配置静态NAT，在内网主机192.168.1.128访问公网时，将他的源IP地址转换为12.1.1.3。（注意配置默认路由）。 nat 配置 12345678910111213141516TPLINK(config)#ip route 0.0.0.0 0.0.0.0 12.1.1.2//配置一条下一跳指向12.1.1.2的默认路由。注意，如果不添加此默认路由，则网关路由器没有到达目的主机的路由会丢弃数据包。但添加去往目的主机的明细路由并不可取，因为目的主机模拟互联网主机，实际上互联网主机的数量会非常庞大，不可能每一个网络的路由都配置在网关路由器上，所以必须使用默认路由。TPLINK(config)#ip nat inside source static 192.168.1.128 12.1.1.3//配置内部源转换静态NAT。将内部本地地址192.168.1.128转换为12.1.1.3。interface Ethernet0/0ip address 192.168.1.1 255.255.255.0ip nat insideinterface Ethernet0/1ip address 12.1.1.1 255.255.255.0ip nat outside//配置接口的IP地址以及NAT方向。注意方向不要写反。且必须配置检查NAT的命令：TPLINK#show ip nat statistics//查看NAT的统计信息，包括配置的内部和外部NAT接口以及NAT的命中情况TPLINK#show ip nat translations//查看NAT转换表，查看已经配置的NAT的转换情况 地址类型 所有Inside的地址，都是属于你内部设备的地址。 所有Outside的地址，都是不属于你内部设备的地址。 所有Local地址，一般是私有IP地址。 所有Global地址，一般是公有IP地址。 Inside Local Address:内部主机使用的私有IP地址。 Inside Global Address:内部主机访问外部网络，将私有IP地址换成的共有IP地址。 Outside Local Address:外部主机访问内部网络，为其分配的私有IP地址。 Outside Global Address:外部主机的公有IP地址。 类型 静态NAT：内部本地地址与内部全局地址的一一对应。每个内部本地地址访问外部网络的时候，需要一个单独的内部全局地址。 动态NAT：内部本地地址数量多余可用的内部全局地址。所有内部全局地址被放入一个NAT地址池。在内部主机需要访问外部网络的时候，从地址池中获取一个内部全局地址并进行NAT，如果地址池空了，则内部主机无法进行NAT。 PAT：端口地址转换，在转换三层地址的同时，对四层的端口号也进行转换，从而支持一个内部全局地址对应多个内部主机。 PAT基本配置 1234TPLINK(config)#access-list 1 permit 192.168.1.0 0.0.0.255//配置一个ACL，匹配NAT的感兴趣流量，本例中，感兴趣流量是源IP地址为192.168.1.0/24的流量。TPLINK(config)#ip nat inside source list 1 interface Ethernet0/1 overload//配置一个内部源转换，对ACL1匹配的感兴趣流进行地址转换，将源地址转换为接口E0/1的IP地址，进行超载转换允许多个内部主机同时通过一个内部全局地址访问公网。 十、简易密码学 特点 机密性：信息不能被非授权的第三方所读取和理解。 数据完整性：信息不能被有意或无意的篡改或破坏。 抗抵赖：不能否认曾经发送过的某些信息或执行过的某些操作。 源认证：对于数据真实的源进行的识别。 反重放：防止重复接收看似合法的数据的副本。 散列算法 例如MD5加密，哈希算法（SHA） HMAC算法 是基于HASH的消息认证代码，使用一个预共享密钥连同数据一起计算散列值。 加密技术 对称加密算法 非对称加密算法十一、ASA防火墙基础 防火墙 常见分区 公共区域：一般指Internet、公共网络、菲私有网络、不受信任、不受保护。 DMZ区域：放置企业的公网服务器。 内部区域：一般指企业内网。 防火墙在各个分区之间强制执行访问控制策略，如果一个区域被攻陷，防止攻击蔓延到另一个区域。 功能 包过滤技术 状态检测技术（节省资源、相对较安全） 应用检测功能（AIC） 代理服务器：是客户端和服务器的一个中转站 IPS与IDS：入侵防御系统和入侵检测系统，与防火墙类似。IPS可以采取阻断的动作，IDS可以向管理员发出警报。 ASA配置 接口配置 接口IP地址：配置防火墙接口的IP地址 接口的安全等级：防火墙接口必须有一个1-100的安全级别。通常接口连接到的区域受信任程度越高，该级别就越高 接口的名字：防火墙接口必须有一个名字，在很多防火墙特性配置的时候，只能引用防火墙的接口名进行配置 开启接口： no shutdown 默认访问控制策略：防火墙默认约需所有出站流量，拒绝所有入站流量。 出站流量：当流量从一个高安全级别接口始发，去往一个低安全级别接口时，被认为是出站流量 入站流量：当流量从一个低安全级别接口始发，去往一个高安全级别接口时，被认为是入站流量 防火墙基本配置 ASA配置 1234567891011121314151617interface GigabitEthernet0/0 nameif DMZ security-level 50 ip address 24.1.1.2 255.255.255.0 interface GigabitEthernet0/1 nameif INSIDE security-level 100 ip address 23.1.1.2 255.255.255.0 interface GigabitEthernet0/2 nameif OUTSIDE security-level 0 ip address 12.1.1.2 255.255.255.0//给每个接口配置了IP地址，接口名以及安全级别。policy-map global_policy class inspection_default inspect icmp//为默认全局策略的默认检测类开启ICMP检测。 路由器开启telnet服务 1234line vty 0 4 login local transport input telnet username name(主机名) password password(密码) ASA网络目标配置 网络目标是一种预定义的元素。分为三种类型，分别是主机(描述一台主机)，范围(描述从某IP地址到某IP地址的一组主机)，子网(描述一个子网的所有主机)。 配置 第一部分：按照图中所示配置所有设备的IP地址。正确配置模拟终端设备的路由器（关路由功能，设默认网关，配置IP地址并开启相应服务）。 配置内网路由：在ASA和CORE之间配置动态路由协议 配置公网路由：在CORE和ASA上配置指向电信的默认路由 配置自动NAT:实现内网客户端访问公网服务器 防火墙接口配置 123456789101112interface GigabitEthernet0/0nameif INSIDEsecurity-level 100ip address 10.1.23.2 255.255.255.0 interface GigabitEthernet0/1nameif OUTSIDEsecurity-level 0ip address 12.1.1.2 255.255.255.0 interface GigabitEthernet0/2nameif DMZsecurity-level 50ip address 10.1.100.254 255.255.255.0 防火墙动态路由配置 1234router rigrp 1network 10.1.12.2 255.255.255.255network 10.1.100.254 255.255.255.255//开启了eigrp进程1，精确宣告了两个内网接口 发布防火墙静态路由配置 12route OUTSIDE 0.0.0.0 0.0.0.0 12.1.1.1//配置了静态的默认路由指向TELECOM 防火墙自动NAT配置 1234object network ITSUBNETsubnet 10.1.1.0 255.255.255.0nat(INSIIDE,OUTSIDE) dynamic interface//配置网络目标NAT（自动NAT），注意缩进。配置从10.1.1.0/24子网发起的流量，从INSIDE接口进入防火墙，从OUTSIDE接口离开防火墙。这些流量将源IP地址转化为接口OUTSIDE的IP地址。 第二部分：要求DMZServer开启HTTP服务，配置自动NAT和严格ACL允许公网主机访问DMZServerHTTP服务。 配置自动NAT 1234object network DMZSERVER1host 10.1.100.1nat(DMZ,OUTSIDE) static 12.1.1.100//将主机10.1.100.1进行静态NAT转换，转换后的地址为12.1.1.100 配置ACL放行OUTSIDE到DMZ的合法流量 1234access-list FORDMZSRV extended permit tcp any host 10.1.100.1 eq www//配置一个叫做FORDMZSRV的ACL，允许任何主机法网10.1.100.1的http流量。注意在这个位置写的IP地址和端口号是服务器的真实IP地址和端口号。access-group FORDMZSRV in interface OUTSIDE//将FORDMZSRV 调用在OUTSIDE接口的入方向上，放行公网主机访问内网服务器的首包。 SSH(安全外壳协议):SSH和TELNET一样都可用于远程访问目标主机的CLI，SSH较安全。SSH使用TCP端口22作为目的 综合实验 实验需求：配置防火墙，实现内网主机可以访问公网的HTTP服务。公网客户端可以访问内网的DMZ服务器的HTTP和SSH服务。要求在防火墙上配置适当的自动NAT策略和严格ACL来完成这个需求。 交换机配置各个VLAN以及各VLAN的SVI接口。交换机连接防火墙的接口使用RSI。 配置IP地址。（主机ping直连检查IP连通性） 配置内网路由（用EIGRP来实现。注意在ASA上连接ISP的接口不要运行EIGRP） 配置默认路由。（三层交换机和防火墙都需要默认路由来确保公网连通性） 配置ACL放行合法流量。（应用在出接口的入方向，ACL必须精确）。 配置自动NAT。（为HR和IT配置动态PAT，让他们能够访问公网，为DMZ服务器配置静态端口映射，让公网能够访问他们）。 实验解答 核心配置 123456789101112131415161718192021222324252627object network SRV1&nbsp;host 10.1.100.1object network SRV2&nbsp;host 10.1.100.2object network SRV3&nbsp;host 10.1.100.3object network IT&nbsp;subnet 10.1.10.0 255.255.255.0object network HR&nbsp;subnet 10.1.20.0 255.255.255.0object service HTTP&nbsp;service tcp destination eq www object service TELNET&nbsp;service tcp destination eq telnetobject-group network SRVCluster&nbsp;network-object object SRV1&nbsp;network-object object SRV2&nbsp;network-object object SRV3object-group network SRVUser&nbsp;network-object object IT&nbsp;network-object object HRobject-group service SRVService&nbsp;service-object object HTTP &nbsp;service-object object TELNET配置并调用ACL：access-list ININSIDE extended permit object-group SRVService object-group SRVUser object-group SRVClusteraccess-group ININSIDE in interface INSIDE ssh配置 123456789101112131415SRV1(config)#hostname SRV1SRV1(config)#ip domain-name zbh.com//配置主机名和域名。主机名和域名对RSA密钥并无影响但RSA生成密钥需要这两个参数作为密钥标签。所以在生成RSA密钥对之前必须先配置主机名和域名。SRV1(config)#crypto key generate rsa modulus 1024//生成一个以1024为素模的RSA密钥对，模数越大，RSA密钥长度越长，强度越高SRV1(config)#ip ssh version 2//开启SSH版本2，SSH版本1的连接会被拒绝。推荐使用SSHv2SRV1(config)#line vty 0 4login local&nbsp;transport input ssh//开启vty线路，并允许在入向传输时使用SSH协议，注意这里没有包括telnet关键字，所以设备当前无法通过telnet进行远程管理。SRV1(config)#username zbh password cisco123//配置本地用户账户数据库用于对SSH远程连接进行身份认证HR#ssh -l zbh 10.1.100.1//以用户名zbh对10.1.100.1发起一个SSH远程访问。注意-l参数后面需要空格再填写用户名。","tags":[{"name":"笔记","slug":"笔记","permalink":"http://lpower.com/tags/笔记/"}]},{"title":"tp5基础","date":"2018-11-30T01:15:51.000Z","path":"2018/11/30/tp5基础/","text":"配置域名 在c盘下Windows文件夹下的system32文件夹下drivers文件夹下的etc文件夹下的hosts文件添加一个配置 1127.0.0.1 www.tp5.com 如果不能修改的话，将文件复制到桌面修改，然后在粘贴回去就完事了。 因为我用的是wamp集成环境，所以配置要在httpd-vhosts.conf下配置：12345678910#&lt;VirtualHost *:80&gt; ServerName www.tp5.com DocumentRoot \"f:/wamp/www/tp5/public\" &lt;Directory \"f:/wamp/www/tp5/public/\"&gt; Options +Indexes +Includes +FollowSymLinks +MultiViews AllowOverride All Require local &lt;/Directory&gt;&lt;/VirtualHost&gt; 如果用户用的的Apache，要修改Httpd.conf 配置 命名规范 目录和文件 目录使用小写+下划线 类文件使用驼峰命名法，首字母大写，其他文件采用小写+下划线命名 类名和类文件名保持一致，统一采用驼峰法命名 函数和类，属性命名 类的命名采用驼峰法，首字母大写。默认不加任何后缀 函数的命名使用小写+下划线命名 方法的命名使用驼峰法，首字母小写 属性的命名使用驼峰法，首字母小写目录结构 url和路由路由：通过用户请求的地址，根据地址的某种规则解析，然后分发到相应的模块相应的控制器地址。 访问路径大小写的注意： TP5全部转换为小写 控制器首字母大写 驼峰式命名要加下划线，如果想区分大小写的话，可以在config.php里将url_convert改为false。配置路由：在route.php里配置URL生成请求和响应 详细内容请看tp5完全开发手册 请求与响应 https://www.kancloud.cn/manual/thinkphp5/158834 页面跳转：可以直接指定路径跳转，也可以重定向跳转。 跳转 总结一下数据库基本操作 数据库配置 在database.php里配置 12345678910111213141516171819202122// 数据库类型 'type' =&gt; 'mysql', // 服务器地址 'hostname' =&gt; '127.0.0.1', // 数据库名 'database' =&gt; '你的数据库名', // 用户名 'username' =&gt; '你的用户名', // 密码 'password' =&gt; '你的密码', // 端口 'hostport' =&gt; '你的端口号', // 连接dsn 'dsn' =&gt; '', // 数据库连接参数 'params' =&gt; [], // 数据库编码默认采用utf8 'charset' =&gt; 'utf8', // 数据库表前缀 'prefix' =&gt; '数据库表的前缀', // 数据库调试模式 'debug' =&gt; true, 一定要确定好自己的配置，否则会出错出到让你心态爆炸的，不要问我怎么知道的！！！！！！！！！！ 如果要操作多数据库，只要在config.php里配置一个数组，数组里是以上的配置就好了。 query execute 原生态SQL语句 增删改查 查询操作用query 其他操作用execute 多个数据库切换查询操作 12Db::connect('db1')-&gt;query(查询语句)Db::connect('db2')-&gt;query(查询语句) 事务支持 需要在数据库中设置表类型为InnoDB以支持事务，然后把需要执行的事务操作封装到闭包里面即可自动完成事务。用Db::transaction函数操作。 手动控制事务的提交。首先启动事务（Db::startTrans()）,然后用try，catch来提交，回滚事务（Db::rollback()）。模型和关联模型是一种对象-关系映射的封装，并且提供了简洁的ActiveRecord实现，一般来说，每个数据表会和一个模型对应。创建一个子类，类名跟数据表名相同（需要用驼峰命名法，会自己转换），继承Model父类。在调用的时候，会自动查询主键。查询范围 scope + 查询范围名称 定义函数 全局查询范围，定义之后，会自动调用 strstr函数搜索一个字符串在另一个字符串中的第一次出现，并返回字符串剩余的部分，对大小写敏感。 12345查找 \"Shanghai\" 在 \"I love Beijing!\" 中的第一次出现，并返回字符串的剩余部分：&lt;?phpecho strstr(\"I love Beijing!\",\"Beijing\");?&gt; 输入与验证简单来说就是表单操作，然后要用validate函数来验证，实现对数据库的操作。 关联一对一：has_one以及相对的belongs_to 多对多：has_many以及相对的belongs_to 一对多：belongs_to_many 视图与模板 volist标签 属性 name(必须)：要输出的数据模板变量 id(必须)：循环变量 offset（可选）：要输出数据的offset length（可选）：输出数据的长度 key（可选）：循环的key变量，默认值为i mod（可选）：对key值取模，默认为2 empty（可选）：如果数据为空显示的字符串 公共模板 模板定位 1234567891011121314151617181920'template' =&gt; [ // 模板引擎类型 支持 php think 支持扩展 'type' =&gt; 'Think', // 默认模板渲染规则 1 解析为小写+下划线 2 全部转换小写 'auto_rule' =&gt; 1, // 模板路径 'view_path' =&gt; '', // 模板后缀 'view_suffix' =&gt; 'html', // 模板文件名分隔符 'view_depr' =&gt; DS, // 模板引擎普通标签开始标记 'tpl_begin' =&gt; '{', // 模板引擎普通标签结束标记 'tpl_end' =&gt; '}', // 标签库标签开始标记 'taglib_begin' =&gt; '{', // 标签库标签结束标记 'taglib_end' =&gt; '}', ], 模板布局 123'layout_on'=&gt;true //开启模板布局'layout_name'=&gt;'layout' //使用layout文件'layout_item'=&gt;'{__CONTENT__}' 图片显示： 模板布局 调试和日志 页面trace(官方推荐) 修改配置，启动调试 12345// 应用Trace'app_trace' =&gt; true,'trace' =&gt; [ // 内置Html Console 支持扩展 'type' =&gt; 'Html', 在显示页面时，浏览器底部会有调试信息 trace 异常页面 直接报错调试，显示错误信息 断点调试 dump调试输出 halt变量调试中断并输出(打印之后就不会再打印) trace 控制台输出 日志分析 log常规日志，用于记录日志 error错误，一般会导致程序的中止 notice 警告，程序可以运行但是不够完美的错误 info 信息，程序输出信息 debug 调试，用于调试信息 sql SQL语句，用于SQL记录，只在数据库的调试模式开启时有效 12345//在runtime下的log文件Log::error('错误信息1');Log::info('日志信息2');trace('错误信息3'，'error');trace('日志信息4'，'info'); 远程调试api调用（需要json返回） api 创建api模块 模拟提交测试（用php工具箱）扩展 如果有些函数需要全栈共用，就要在application\\common.php文件中自己定义。创建的类库存放于extend目录下面，在extend\\org\\文件名.php，跟项目有关系的类放在application\\common\\文件名.php。如果没有这些文件夹，需要自己创建。 驱动扩展 扩展 session与cookie session文件存放位置 php.ini session.save_path 开启session session_start tp5里session设置config.php 1234567891011121314151617'session' =&gt; [ 'id' =&gt; '', // SESSION_ID的提交变量,解决flash上传跨域 'var_session_id' =&gt; '', // SESSION 前缀 'prefix' =&gt; 'think', // 驱动方式 支持redis memcache memcached 'type' =&gt; '', // 是否自动开启 SESSION 'auto_start' =&gt; true, ], session::set() //赋值当前作用域 session::has() //判断 session::get() //取值 session::delete() //删除 session::clear() //清除session cookie 1234567891011121314151617181920'cookie' =&gt; [ // cookie 名称前缀 'prefix' =&gt; '', // cookie 保存时间 'expire' =&gt; 0, // cookie 保存路径 'path' =&gt; '/', // cookie 有效域名 'domain' =&gt; '', // cookie 启用安全传输 'secure' =&gt; false, // httponly设置 'httponly' =&gt; '', // 是否使用 setcookie 'setcookie' =&gt; true, ], cookie::set() //设置cookie cookie::delete() //删除 cookie::clear() //清除cookie 支持数组，支持使用cookie类直接读取 验证码安装composer，然后使用它安装验证码类库 文件上传 上传form表单的enctype属性一定要设置成multipart/form-data 校验：用validate方法校验上传的是否是需要的文件 上传 md5是表示用MD5方式命名，也可改为date，即根据上传时间命名。如果想要保持上传文件的原文件名，可以将rule(‘md5’)改为$file. 多文件上传 将单文件上传foreach循环遍历，变为多文件上传图像处理 安装图像处理类库 图片读取 Image::open($file) 1234567891011121314//图片裁剪(宽度，高度，x坐标，y坐标)$image-&gt;crop(300,300,200,200);//缩略图(最大宽度，最大高度，裁剪类型)$image-&gt;thumb(150,150,Image::THUMB_CENTER);//垂直翻转$image-&gt;flip();//水平翻转$image-&gt;flip(Image::FLIP_Y);//图片旋转(顺时针旋转的度数)$image-&gt;rotate(30);//图片水印$image-&gt;water(ROOT_PATH.'图片名',Image::WATER_NORTHWEST,50)//文字水印(水印文字，字体文件路径，文字大小，文字颜色，文字写入位置，偏移量，文字倾斜角度)$image-&gt;text(); 图片保存 $image-&gt;save()tp5自带的方法 分页：paginate 需要在模板中使用：{$data-&gt;render()} tp5中url的写法 href=”{:url(‘admin/index’)}?Id={$data[‘Id’]}” href=”{:url(‘index/download’,[‘Id’=&gt;$data[‘Id’]])}” validate验证 附tp5完全开发手册：https://www.kancloud.cn/manual/thinkphp5/content","tags":[{"name":"tp5","slug":"tp5","permalink":"http://lpower.com/tags/tp5/"}]},{"title":"PHPmvc笔记","date":"2018-11-25T11:52:23.000Z","path":"2018/11/25/PHPmvc笔记/","text":"因为是在学习的中途才写的笔记，所以有一些不全，以后有时间会补全，现在主要是关于samrty语法的多。 含义：MVC是一种设计模式，它强制性的使应用程序的输入，处理和输出分开。使用MVC应用程序被分成三个核心部件：模型（Model），视图（View），控制器（Controller），他们各自处理自己的任务。 模型：处理数据和业务逻辑 视图：通过布局向用户展示数据 控制器：接收用户请求，并调用相应的模型处理 单一入口机制：指在一个web应用程序中，所有的请求都是指向一个脚本文件，所有对实用程序的访问都必须通过这个入口。 eval()函数：把字符串转换为可执行的PHP语句。 addslashes()函数：对特殊符号进行转义。 in_array()函数：判断字符串是否在数组里面 smarty语法 配置12345678910111213 require(\"libs/Smarty.class.php\");//引入模板 $smarty = new Smarty(); $smarty-&gt;left_delimiter = \"{\"; //左定界符 $smarty-&gt;right_delimiter = \"}\"; //右定界符 $smarty-&gt;template_dir = \"tpl\"; //html模板的地址 $smarty-&gt;compile_dir = \"template_c\"; //模板编译生成的文件 $smarty-&gt;cache_dir = \"cache\"; //缓存 $smarty-&gt;caching = false;``` * 函数1. assign()函数：向模板里注册变量，变量名是第一个参数，变量值是第二个参数。2. display()函数：展示函数，在网页里展示，参数为模板文件。* 编写模板：test.tpl {变量名}123456789* 基本语法1. 注释 {* 这里是注释的语句 *}2. 常用变量调节器 1. 首字母大写capitalize 例：`{$test|capitalize}` 2. 字符串连接cat 例：`{$test|cat:\"yesterday\"}` 3. 日期格式化date_format 例： `{$yesterday|date_format}` 4. 为未赋值或为空的变量指定默认值default 例：`{$title|default:\"no title\"}` 5. 转换变量字符串大小写upper(转换为大写) lower（转换为小写）： 例： `{$test|upper} {$TEST|lower}`3. 条件判断语句： {if 条件} ...... {elseif 条件} ...... {else} ...... {/if} 12 其中条件修饰符eq相当于==，neq相当于!=，gt相当于&gt;，lt相当于&lt;。3. 循环语句 {foreach item=被赋值的量 from=变量名} ....... ....... {foreachelse} {/foreach} ``` 在smarty3里，foreach与php源生语法一致，`{foreach $test as $tt}` 插件 使用registerPlugin方法注册写好的自定义函数 将写好的插件放入Smarty解压目录下lib目录下的plugins目录里 php的内置函数，可以自动以修饰插件的形式在模板里运用","tags":[{"name":"笔记","slug":"笔记","permalink":"http://lpower.com/tags/笔记/"}]},{"title":"数据结构基础","date":"2018-11-25T08:45:32.000Z","path":"2018/11/25/数据结构/","text":"数组 泛型：使数据结构可以放置除boolean,byte,char,short,int,long,float,double这八种基础数据类型以外所有数据类型，如果想放置这八种基本类型，可以用对应的包装类。 在声明类的时候，在类名后加&lt;类型&gt;。下面要实例化数组的时候，要强制转换。例如： 123456public class Array&lt;E&gt;{ private E[] data; public Array(int cap){ data = (E[]) new Object[cap]; }} 简单的时间复杂度分析 大O 描述的是算法的运行时间和输入数据之间的关系，分析时忽略常数。 O(n)翻译过来应该是渐进时间复杂度，它描述的是当n趋于无穷的情况。 严格计算需要一些概率论知识。 均摊复杂度：将复杂度较高的算法和其他操作放在一起分析复杂度。这个复杂度较高的的算法复杂度将会均摊到其他的操作中。 复杂度震荡：存在某种情况，刚刚进行了一次数组的删除操作，缩容了一次数组，此时数组元素个数正好等于数组的容量，后面又对数组进行了一次添加操作，就会又要给数组进行一次扩容，这样整个算法的复杂度就会上升，这就是所谓的复杂度震荡。 解决复杂度震荡：推迟数组的缩容操作。当某个元素等于数组容量的1/4时，在进行缩容，缩容为当前数组容量的1/2.这样就可以很好地解决复杂度震荡问题。 栈 栈是一种线性结构，是数组的子集，只能从一端添加元素，也只能从一端取出元素，这一端称为栈顶。 栈是一种后进先出的数据结构（LIFO），撤销操作就是典型的栈的操作。 基本操作 123456Stack&lt;E&gt; //泛型void push(E)//入栈E pop() //出栈E peek() //栈顶元素（E top()）int getSize() //共有几个元素boolean isEmpty() //判断是否为空 队列 队列也是一种线性结构，是数组的子集，只能从一端（队尾）添加元素，只能从另一端（队首）取出元素 队列是一种先进先出的数据结构（先到先得），First in First Out(FIFO) 基本操作 123456Queue&lt;E&gt; //泛型void enqueue(E)//入队E dequeue() //出队E getFront() //队首元素int getSize() //共有几个元素boolean isEmpty() //判断是否为空 循环队列：front==tail 队列为空，当填入一个元素时，tail++，直至(tail+1) % c==front时，队列满，就可以扩容队列了。这样，队列是有意识的浪费一个空间 数据结构 循环队列比数组快很多，容量越大，区别越大。 链表 -&gt;真正的动态数据结构 链表是最简单的动态数组结构，对递归和指针可以更深入的理解 数据存储在节点（Node）中，是真正的动态，不需要处理固定容量的问题，但是丧失了随机访问的能力 在执行链表代码时，顺序很重要，不能前后顺序颠倒。 在链表头增加数据时，为链表设立虚拟头结点（dummyHead）。 在删除链表时，要先找到待删除的节点的上一个节点，让这个节点指向待删除的节点的下一个节点。 链表 可以用链表实现栈和队列。链表与递归 递归本质上就是将原来的问题转化为更小的同一问题。 数组求和问题：实际上就是从第一个加到最后一个，然后一个一个将数取出来，最后只剩最后一个数加上一个空数组，实现如下： 递归算法。 求解最基本问题 把原问题转化为更小的问题 链表具有天然递归结构性质 递归调用是有代价的：函数调用+系统栈空间","tags":[{"name":"笔记","slug":"笔记","permalink":"http://lpower.com/tags/笔记/"}]},{"title":"wamp下基础sql语句","date":"2018-11-22T10:47:07.000Z","path":"2018/11/22/wamp下基础sql语句/","text":"环境搭建实验环境：wamp-SQL控制台 设置MySQL的密码 默认密码为空，直接回车登录 use mysql; 修改密码 1update user set authentication_string = PASSWORD('你自己的密码') where user='root'; 使设定立即生效 1flush privileges; exit 退出； 基础语句 登陆wamp； 查看基本配置 查询服务器版本 select version（） 查询用户权限 select user（） 查询当前所在的库 select database（） 显示数据库列表 show databases 建库 create database user 建表 use user 1create table （id int username varchar(20)password varchar(20） 往表中加入记录 1insert into admin values(1,'admin','hhh') 显示表的字段信息 desc 表名 12345678mysql&gt; desc admin;+----------+-------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+----------+-------------+------+-----+---------+-------+| id | int(11) | YES | | NULL | || username | varchar(20) | YES | | NULL | || password | varchar(20) | YES | | NULL | |+----------+-------------+------+----- 查询操作 查询admin中所有数据 select * from 表名; 12345678910mysql&gt; select * from admin;+------+----------+----------+| id | username | password |+------+----------+----------+| 1 | admin | hhh || 1 | user | dida || 1 | hack | zzz || 2 | use | ida || 3 | hak | zz |+------+----------+----------+ （因为手残所以多加了两个id=1的 以后忽略） 查询admin中id=2的信息select * from 表名 where id =2 123456mysql&gt; select * from admin where id =2;+------+----------+----------+| id | username | password |+------+----------+----------+| 2 | use | ida |+------+----------+----------+ 查询admin中id=2的用户名和密码select username,password from admin where id =2; 123456mysql&gt; select username,password from admin where id =2;+----------+----------+| username | password |+----------+----------+| use | ida |+----------+----------+ 判断其他表是否存在 1select * from admin where id=‘1’and exists(select * from task） 如果不存在 会出现Table ‘user.task’ doesn’t exist 12 mysql&gt; select * from admin where id='2'and exists(select * from task );ERROR 1146 (42S02): Table 'user.task' doesn't exist 一些不常用的 @@version_compile_os显示服务器系统 @@basedir 显示MySQL的安装路径 @@datadir 显示MySQL数据库文件的路径 order by n 查字段与排序123456789101112mysql&gt; select * from admin order by 4;ERROR 1054 (42S22): Unknown column '4' in 'order clause'mysql&gt; select * from admin order by 3;+------+----------+----------+| id | username | password |+------+----------+----------+| 1 | user | dida || 1 | admin | hhh || 2 | use | ida || 3 | hak | zz || 1 | hack | zzz |+------+----------+-- 联合查询：前后字段必须一致。 告诉服务器你的字符集 1mysql&gt;set names gbk/utf-8 快速清空表truncate 表名 distinct 在结果中去除重复行 1mysql&gt; select distinct name from aaa; order by 对结果排序 1select * from hhh order by id; 修改数据表记录 1mysql&gt; update hhh set age='15' where id='3'; concat联合多列 1mysql&gt; select id,concat(name,\":\",age) from hhh; 修改字符编码 1alter table users modify username char(20) character set gbk; 建立索引 1create unique index &lt;索引名&gt; on &lt;表名&gt; &lt;列名&gt;","tags":[{"name":"sql语句","slug":"sql语句","permalink":"http://lpower.com/tags/sql语句/"}]},{"title":"hexo博客上传图片","date":"2018-11-22T04:38:39.000Z","path":"2018/11/22/hexo博客上传图片/","text":"今天想写博客，突然发现要用到图片，然而自己却不会上传，于是就拜托了谷歌大神。一开始下载了插件之后，发现不好用，于是用了七牛云。七牛云很麻烦，还要实名认证。所以我还是决定用插件来操作。话不多说，看操作。1.首先把hexo下的_config.yml下的post_asset_folder改为true2.在hexo目录下git bash here 1npm install hexo-asset-image --save 3.之后你再hexo n “博客名”生成md博客时，在_post目录下会生成一个与博客名相同的文件夹。4.将想要上传的图片放到文件夹下，用markdown插入图片：1![想输入的文字](文件夹名/图片名.jpg) 5.用hexo上传博客。一波小小的福利 福利","tags":[{"name":"hexo","slug":"hexo","permalink":"http://lpower.com/tags/hexo/"}]},{"title":"mysql8.0的安装","date":"2018-10-02T06:43:26.000Z","path":"2018/10/02/mysql8-0的安装/","text":"Windows下MySQL安装今天闲来无事，就脑残的想安装个MySQL玩玩，结果遇到了各种各样的麻烦，搞得心态差点炸了，还好最后安装完了。1.官网下载社区版MySQL（zip包），然后解压。2.配置环境变量。 我的电脑-&gt;右键-&gt;高级系统设置-&gt;环境变量，在系统变量的path后添加解压后的MySQL文件夹里的bin目录的路径 3.添加配置文件在MySQL文件夹下创建my.ini文件1234567891011121314[mysql]# 设置mysql客户端默认字符集default-character-set=utf8[mysqld]# 设置3306端口port = 3306# 设置mysql的安装目录basedir=C:\\web\\mysql-8.0.11# 设置mysql数据库的数据的存放目录datadir=C:\\web\\sqldata# 允许最大连接数max_connections=20# 服务端使用的字符集默认为8比特编码的latin1字符集character-set-server=utf8 4.以管理员身份运行cmd（在搜索框敲cmd，右键，以管理员身份运行）这里一定一定要用管理员身份运行cmd，不然在后续步骤时会报错进入cmd后切到bin目录下，初始化数据库1mysqld --initialize --console 待执行完成后，会出现root的初始密码root@localhost后面的字符串就是密码记住密码，保存下来，之后第一次登陆时会用到。 5.安装mysqld1mysqld -install 6.启动MySQL1net start mysql 这里就是上文提到的如果不是管理员身份运行，会提示安装失败。 7.上述步骤完成后，就不需要管理员权限了，直接cmd1mysql -u root -p 回车后会提示输入密码，把刚才保存的输入密码输入之后就可以登录了 8.修改密码因为初始密码过于难记，所以大部分人都需要重置密码，重置密码有很多种方法，我试了很多，只有下面这条能用1alter user 'root'@'localhost' identified by '你的密码'; 其他的都会报错，这里一定要有耐心，因为我不知道试了多少语句。 9.刷新，使修改生效1flush privileges; 10.退出，重新登陆MySQL退出mysql1exit 重新登陆MySQL1mysql -u root -p 然后输入你修改后的密码，发现能够登陆，MySQL安装完成 附：mysql的导入导出1.导入： 运行cmd mysql -u 用户名 -p 密码 source 数据库名 &lt; 要导入的文件名.sql2.导出： 到MySQL的bin目录下，运行cmd 输入 mysqldump 数据库名 &gt; 文件名.sql。如果要指定路径，例如如果想放到C盘下，可以直接 mysqldump 数据库名 &gt; c:\\文件名.sql当然还有一种更简单的方法，就是直接用图形化界面，直接导出。","tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://lpower.com/tags/MySQL/"}]},{"title":"js,jquery的一点小基础","date":"2018-07-25T08:05:05.000Z","path":"2018/07/25/js的一点小基础/","text":"一、javascript 使用 HTML 中的脚本必须位于 与 标签之间。脚本可被放置在 HTML 页面的 和 部分中 .github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; } .github-emoji > span { position: relative; z-index: 10; } .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; } .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; } 输出 document.write() 大部分的输出方式，写到文档输出 document.getElementById(id) 用id属性标识HTML元素，达到访问目的 123456789&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;body&gt;&lt;p id=\"demo\"&gt;biaoqian&lt;/p&gt;&lt;script&gt;document.getElementById().innerText;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; JavaScript严格区分大小写 函数 toUpperCase() 小写转大写 getDay() 得到现在的日期 错误 用try，catch检测，try与catch不可分割，成对出现。try语句里是有错的代码块，catch语句输出错误信息。throw 抛出异常 。可用可不用 HTML事件 123456onchange HTML元素改变onclick 用户点击HTML元素onmouseover 用户在一个HTML元素上移动鼠标onmouseout 用户在一个HTML元素上移开鼠标ionkeydown 用户按下键盘按键onload 浏览器已完成页面的加载 可用于处理表单验证，用户输入，用户行为及浏览器动作。 判断对象的具体类型 通过instanceof操作符来判断 123456arr = [1,2,3];if(arr instanceof Array){ document.write(\"arr 是一个数组\");} else { document.write(\"arr 不是一个数组\");} 如果是返回true，如果不是则返回false。 严格模式（可用可不用） 不允许使用未声明的变量 不允许删除变量或对象 不允许删除函数 不允许变量重名 不允许使用八进制 不允许使用转义字符 不允许对只读属性赋值 不允许对一个使用getter方法读取的属性进行复制 变量名不能使用eval，arguments字符串 保留关键字二、jQuery 语法 通过选取HTML元素，并对选取的元素执行某些操作 基础语法：$(selector)action() ‘$’定义jQuery 选择符selector 查询和查找HTML元素 action()执行对元素的操作 为了防止文档在完全加载（就绪）之前运行 jQuery 代码，即在 DOM 加载完成后才可以对 DOM 进行操作，jQuery函数要在一个ready函数中 123$(function(){ //jquery代码}); 选择器 元素选择器：基于元素名选取元素 12//在页面中选取所有&lt;p&gt;元素$(\"p\") #id选择器，通过唯一id选取指定元素 .class选择器，通过指定的class选取元素 jQuery事件 click()当按钮点击事件被触发时会调用一个函数 mouseenter()当鼠标指针穿过元素时，会发生mouseenter事件 mouseleave()当鼠标指针离开元素时，会发生mouseleave事件 focus() 当元素获得焦点时，发生focus事件 jQuery Dom操作 获取、设置内容text() - 设置或返回所选元素的文本内容 html() - 设置或返回所选元素的内容（包括 HTML 标记） val() - 设置或返回表单字段的值 获取、设置属性：attr()获取属性值 添加元素 append() 在被选元素的结尾插入内容 preappend() 在被选元素的开头插入内容 before() 在被选元素之前插入内容 after() 在被选元素之后插入内容 遍历 向上遍历Dom parent方法返回被选元素的直接父元素 parents方法返回被选元素的所有父元素，一路向上，一直到根元素 parentsUntil方法返回介于两元素之间的 所有祖先元素 向下遍历 children方法返回被选元素的所有直接子元素 find方法返回被选元素的所有后代元素，一路向下到最后一个后代 水平遍历 siblings返回被选元素的所有同胞元素 next返回被选元素的下一个同胞元素","tags":[{"name":"js","slug":"js","permalink":"http://lpower.com/tags/js/"},{"name":"jQuery","slug":"jQuery","permalink":"http://lpower.com/tags/jQuery/"}]},{"title":"first","date":"2018-07-06T03:39:32.000Z","path":"2018/07/06/first/","text":"你好，欢迎来到lpower’s的博客","tags":[]}],"categories":[],"tags":[{"name":"代码","slug":"代码","permalink":"http://lpower.com/tags/代码/"},{"name":"linux","slug":"linux","permalink":"http://lpower.com/tags/linux/"},{"name":"设计模式","slug":"设计模式","permalink":"http://lpower.com/tags/设计模式/"},{"name":"正则","slug":"正则","permalink":"http://lpower.com/tags/正则/"},{"name":"Java基础","slug":"Java基础","permalink":"http://lpower.com/tags/Java基础/"},{"name":"环境搭建","slug":"环境搭建","permalink":"http://lpower.com/tags/环境搭建/"},{"name":"调试","slug":"调试","permalink":"http://lpower.com/tags/调试/"},{"name":"redis","slug":"redis","permalink":"http://lpower.com/tags/redis/"},{"name":"HTTP","slug":"HTTP","permalink":"http://lpower.com/tags/HTTP/"},{"name":"笔记","slug":"笔记","permalink":"http://lpower.com/tags/笔记/"},{"name":"tp5","slug":"tp5","permalink":"http://lpower.com/tags/tp5/"},{"name":"sql语句","slug":"sql语句","permalink":"http://lpower.com/tags/sql语句/"},{"name":"hexo","slug":"hexo","permalink":"http://lpower.com/tags/hexo/"},{"name":"MySQL","slug":"MySQL","permalink":"http://lpower.com/tags/MySQL/"},{"name":"js","slug":"js","permalink":"http://lpower.com/tags/js/"},{"name":"jQuery","slug":"jQuery","permalink":"http://lpower.com/tags/jQuery/"}]}